
<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    

<meta charset="utf-8" >

<title>leetcode第4题：两个排序数组的中位数题解</title>
<meta name="keywords" content="leetcode第4题：两个排序数组的中位数题解, Hiccup&#39;s Blog">
<meta name="description" content="简介做到第四题，感觉好难，复杂度O(log(m+n))不好做，觉得该二分，做了一个小时放弃了，感觉没大一大二那种一直做下去，几个小时都不放弃的精力了，也可能是天气太热…..索性看了看官方的题解，顿时感觉茅塞顿开，我就把那题解放到这来吧。原文">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style/main.css">


<link rel="stylesheet" href="/style/jquery.fancybox.min.css">







  <meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Hiccup's Blog" type="application/atom+xml">
</head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://xdong.me">
        <img class="avatar" src="/images/avatar.png" alt="" width="32px" height="32px">
      </a>
      <a href="https://xdong.me">
        <h1 class="site-title">Hiccup&#39;s Blog</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        首页
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        标签
      </a>
    
  
    
      <a href="/categories" class="menu purple-link">
        分类
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        归档
      </a>
    
  
    
      <a href="/friends" class="menu purple-link">
        友链
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        关于
      </a>
    
  
</nav>
</div>


      <div class="content-container">
        <div class="post-detail">
          
          <h2 class="post-title">leetcode第4题：两个排序数组的中位数题解</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon icon-calendar-outline"></i> 2018-09-19</span>
            
              <span>
              <i class="icon icon-pricetags-outline"></i>
                
                  <a href="/tags/JAVA/">
                  JAVA
                    
                      ，
                    
                  </a>
                
                  <a href="/tags/leetcode/">
                  leetcode
                    
                  </a>
                
              </span>
            
          </div>
          <div class="post-content-wrapper">
            <div class="post-content">
              <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>做到第四题，感觉好难，复杂度O(log(m+n))不好做，觉得该二分，做了一个小时放弃了，感觉没大一大二那种一直做下去，几个小时都不放弃的精力了，也可能是天气太热…..索性看了看官方的题解，顿时感觉茅塞顿开，我就把那题解放到这来吧。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/#">原文链接</a></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>为了解决这个问题，我们需要理解“中位数的作用是什么”。在统计中，中位数被用来：</p>
<blockquote>
<p>将一个集合划分为两个长度相等的子集，其中一个子集中的元素总是大于另一个子集中的元素。</p>
</blockquote>
<p>如果理解了中位数的划分作用，我们就很接近答案了。</p>
<p>首先，让我们在任一位置  将 A 划分成两个部分：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   left_A                |        right_A</span><br><span class="line">A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>由于 A 中有 m 个元素， 所以我们有 m+1 种划分的方法（i=0∼m）。</p>
<p>我们知道：</p>
<blockquote>
<p>len(left_A)=i,len(right_A)=m−i.</p>
</blockquote>
<blockquote>
<p>注意：当 i=0 时，left_A 为空集， 而当 i=m 时, right_A 为空集。</p>
</blockquote>
<p>采用同样的方式，我们在任一位置 j 将 B 划分成两个部分：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  left_B                 |        right_B</span><br><span class="line">B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>将 left_A 和 left_B 放入一个集合，并将 rright_A 和 right_B 放入另一个集合。 再把这两个新的集合分别命名为 left_part 和 right_part：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      left_part          |        right_part</span><br><span class="line">A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]</span><br><span class="line">B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]</span><br></pre></td></tr></tbody></table></figure>

<p>如果我们可以确认：</p>
<blockquote>
<p>1.len(left_part)=len(right_part)<br>2.max⁡(left_part)≤min⁡(right_part)</p>
</blockquote>
<p>那么，我们已经将 {A,B} 中的所有元素划分为相同长度的两个部分，且其中一部分中的元素总是大于另一部分中的元素。那么：</p>
<p>median=max(left_part)+min(right_part)​ / 2</p>
<p>要确保这两个条件，我们只需要保证：</p>
<blockquote>
<p>1.i+j=m−i+n−j（或：m−i+n−j+1） 如果 n≥m，只需要使  i=0∼m, j=(m+n+1)/2−i<br>2.B[j−1]≤A[i] 以及 A[i−1]≤B[j]</p>
</blockquote>
<p>ps.1 为了简化分析，我假设 A[i−1],B[j−1],A[i],B[j]总是存在，哪怕出现 i=0，i=m，j=0，或是 j=n 这样的临界条件。 我将在最后讨论如何处理这些临界值。</p>
<p>ps.2 为什么 n≥m？由于0≤i≤m且 j=(m+n+1)/2−i，我必须确保 j 不是负数。如果 n&lt;m，那么 j 将可能是负数，而这会造成错误的答案。</p>
<p>所以，我们需要做的是：</p>
<blockquote>
<p>在 [0，m] 中搜索并找到目标对象 i，以使：<br>B[j−1]≤A[i] 且  A[i−1]≤B[j],其中 j=(m+n+1)/2−i</p>
</blockquote>
<p>接着，我们可以按照以下步骤来进行二叉树搜索：</p>
<p>设 imin=0，imax=m, 然后开始在 [imin,imax] 中进行搜索。<br>令 i=(imin+imax)/2​， j=(m+n+1)/2−i</p>
<p>现在我们有 len(left_part)=len(right_part)。 而且我们只会遇到三种情况：</p>
<p>B[j−1]≤A[i] 且 A[i−1]≤B[j]：<br>这意味着我们找到了目标对象 i，所以可以停止搜索。</p>
<p>B[j−1]&gt;A[i]：<br>这意味着 A[i] 太小，我们必须调整 i 以使 B[j−1]≤A[i]。<br>我们可以增大 i 吗？<br>是的，因为当 i 被增大的时候，j 就会被减小。<br>因此 B[j−1] 会减小，而 A[i] 会增大，那么 B[j−1]≤A[i] 就可能被满足。<br>我们可以减小 i 吗？<br>不行，因为当 i 被减小的时候，j 就会被增大。<br>因此 B[j−1] 会增大，而 A[i] 会减小，那么 B[j−1]≤A[i] 就可能不满足。<br>所以我们必须增大 i。也就是说，我们必须将搜索范围调整为 [i+1,imax]。 因此，设imin=i+1并转到步骤 2。</p>
<p>A[i−1]&gt;B[j]： 这意味着 A[i−1] 太大，我们必须减小 i 以使 A[i−1]≤B[j]。 也就是说，我们必须将搜索范围调整为 [imin,i−1]。<br>因此，设 imax=i−1，并转到步骤 2。</p>
<p>当找到目标对象 i 时，中位数为：</p>
<blockquote>
<p>max(A[i−1],B[j−1]),  当 m+n 为奇数时</p>
</blockquote>
<blockquote>
<p>max⁡(A[i−1],B[j−1])+min⁡(A[i],B[j])/2, ​,  当 m+n为偶数时</p>
</blockquote>
<p>现在，让我们来考虑这些临界值 i=0,i=m,j=0,j=n，此时 A[i−1],B[j−1],A[i],B[j] 可能不存在。 其实这种情况比你想象的要容易得多。</p>
<p>我们需要做的是确保 max(left_part)≤min(right_part)。 因此，如果 i 和 j 不是临界值（这意味着 A[i−1],B[j−1],A[i],B[j]全部存在）, 那么我们必须同时检查 B[j−1]≤A[i] 以及 A[i−1]≤B[j] 是否成立。 但是如果 A[i−1],B[j−1],A[i],B[j] 中部分不存在，那么我们只需要检查这两个条件中的一个（或不需要检查）。 举个例子，如果 i=0，那么 A[i−1]不存在，我们就不需要检查 A[i−1]≤B[j] 是否成立。 所以，我们需要做的是：</p>
<blockquote>
<p>在 [0，m] 中搜索并找到目标对象 i，以使：<br>(j=0 or i=m or B[j−1]≤A[i]) 或是 (i=0 or j=n or A[i−1]≤B[j]), 其中 j=(m+n+1)/2−i</p>
</blockquote>
<p>在循环搜索中，我们只会遇到三种情况：</p>
<blockquote>
<p>(j=0 or i=m or B[j−1]≤A[i])) 或是(i=0 or j=n or A[i−1]≤B[j])这意味着 i 是完美的，我们可以停止搜索。<br>j&gt;0 and i&lt;m and B[j−1]&gt;A[i]这意味着 i 太小，我们必须增大它。<br>i&gt;0 and j&lt;n and A[i−1]&gt;B[j]这意味着 i 太大，我们必须减小它。</p>
</blockquote>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution {</span><br><span class="line">    public double findMedianSortedArrays(int[] A, int[] B) {</span><br><span class="line">        int m = A.length;</span><br><span class="line">        int n = B.length;</span><br><span class="line">        if (m &gt; n) { // to ensure m&lt;=n</span><br><span class="line">            int[] temp = A; A = B; B = temp;</span><br><span class="line">            int tmp = m; m = n; n = tmp;</span><br><span class="line">        }</span><br><span class="line">        int iMin = 0, iMax = m, halfLen = (m + n + 1) / 2;</span><br><span class="line">        while (iMin &lt;= iMax) {</span><br><span class="line">            int i = (iMin + iMax) / 2;</span><br><span class="line">            int j = halfLen - i;</span><br><span class="line">            if (i &lt; iMax &amp;&amp; B[j-1] &gt; A[i]){</span><br><span class="line">                iMin = i + 1; // i is too small</span><br><span class="line">            }</span><br><span class="line">            else if (i &gt; iMin &amp;&amp; A[i-1] &gt; B[j]) {</span><br><span class="line">                iMax = i - 1; // i is too big</span><br><span class="line">            }</span><br><span class="line">            else { // i is perfect</span><br><span class="line">                int maxLeft = 0;</span><br><span class="line">                if (i == 0) { maxLeft = B[j-1]; }</span><br><span class="line">                else if (j == 0) { maxLeft = A[i-1]; }</span><br><span class="line">                else { maxLeft = Math.max(A[i-1], B[j-1]); }</span><br><span class="line">                if ( (m + n) % 2 == 1 ) { return maxLeft; }</span><br><span class="line"></span><br><span class="line">                int minRight = 0;</span><br><span class="line">                if (i == m) { minRight = B[j]; }</span><br><span class="line">                else if (j == n) { minRight = A[i]; }</span><br><span class="line">                else { minRight = Math.min(B[j], A[i]); }</span><br><span class="line"></span><br><span class="line">                return (maxLeft + minRight) / 2.0;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return 0.0;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>复杂度分析</p>
<p>时间复杂度：O(log⁡(min(m,n)))，<br>首先，查找的区间是 [0,m]。 而该区间的长度在每次循环之后都会减少为原来的一半。 所以，我们只需要执行 log⁡(m) 次循环。由于我们在每次循环中进行常量次数的操作，所以时间复杂度为 O(log⁡(m))。 由于 m≤n，所以时间复杂度是 O(log⁡(min(m,n)))。</p>
<p>空间复杂度：O(1)， 我们只需要恒定的内存来存储 9 个局部变量， 所以空间复杂度为 O(1)。</p>

            </div>
            <div class="top-div">
              <ol class="top-box"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E7%AE%80%E4%BB%8B"><span class="top-box-text">简介</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="top-box-text">解决方案</span></a></li></ol>
            </div>
          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="/2018/09/18/pai-xu-suan-fa-zong-jie/">
              <h3 class="post-title">
                下一篇：排序算法总结
              </h3>
            </a>
          </div>
        
      </div>

    


      <footer>
<div class="site-footer">
  <div class="social-container">
    
      
        <a href="https://github.com/Hiccup1" target="_blank">
          <i class="icon icon-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
  
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
  
  
  
  
  
  
</div>
</footer>


    </div>
    
    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.fancybox.min.js"></script>


<script src="/js/main.js"></script>





  </body>
</html>
