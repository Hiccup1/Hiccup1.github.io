{"meta":{"title":"Hiccup","subtitle":null,"description":"都是小人物,会点代码就行了","author":"Hiccup","url":"https://xdong.me"},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2019-08-25T12:07:12.778Z","comments":false,"path":"about/index.html","permalink":"https://xdong.me/about/index.html","excerpt":"","text":"关于Hiccup的个人博客 关于我22岁 刚毕业、网络工程专业、做Java相关工作 两年ACM经历 了解c、c++、Java、Linux 关于地点现居深圳 关于学习正在学习Java Web＋Linux… 关于介绍 都是小人物，会点代码就行了 关于爱好看电影、打游戏、写代码 联系我Blog: Hiccup’s BlogEmail: i@xdong.meGitHub: Hiccup1Zhihu: Hiccup","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2019-08-22T13:50:09.000Z","comments":false,"path":"bangumi/index.html","permalink":"https://xdong.me/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-08-22T13:50:09.000Z","comments":false,"path":"client/index.html","permalink":"https://xdong.me/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-08-22T13:50:09.000Z","comments":true,"path":"comment/index.html","permalink":"https://xdong.me/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-08-22T13:50:09.000Z","comments":false,"path":"donate/index.html","permalink":"https://xdong.me/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"","date":"2019-02-17T10:04:02.835Z","updated":"2018-09-19T12:55:41.746Z","comments":true,"path":"friends/index.html","permalink":"https://xdong.me/friends/index.html","excerpt":"","text":"友情链接 hjthjthjt EwdAger 张博玮 邱滔 王颖棋 周学长"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-08-22T13:50:09.000Z","comments":false,"path":"lab/index.html","permalink":"https://xdong.me/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2019-08-25T11:57:29.008Z","comments":true,"path":"links/index.html","permalink":"https://xdong.me/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-08-25T12:09:23.253Z","comments":false,"path":"music/index.html","permalink":"https://xdong.me/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-08-22T13:50:09.000Z","comments":true,"path":"rss/index.html","permalink":"https://xdong.me/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-08-22T13:50:09.000Z","comments":true,"path":"tags/index.html","permalink":"https://xdong.me/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-08-22T13:50:09.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://xdong.me/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-08-22T13:50:09.000Z","comments":false,"path":"video/index.html","permalink":"https://xdong.me/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"bootstrapTable的生成、动态列、样式渲染","slug":"bootstrapTable的生成、动态列、样式渲染","date":"2019-08-23T14:16:01.000Z","updated":"2019-08-25T11:19:47.464Z","comments":true,"path":"2019/08/23/bootstrapTable的生成、动态列、样式渲染/","link":"","permalink":"https://xdong.me/2019/08/23/bootstrapTable的生成、动态列、样式渲染/","excerpt":"","text":"最近工作用到很多bootstrap的知识，以前我只是简单的用他的响应式样式，关于table生成这种没怎么用过，现在总结一下其中的知识也算复习了。 bootstrapTable 生成提供的table我们只需要设置一些参数，比如ajax的参数、列名、分页、排序等等就可以自动发送请求获得结果，渲染成表格，这个直接看文档就会，主要是那些参数和方法要多看看，有些很有用。这里提几个: columns 列配置项，是一个数组[]，我们可以自定义var构建这个列参数，也可以直接写好。 { filed: xxx //表示列的主体内容，这个内容要对应后台参数中的名称，比如后台数据[{id:123}]，那么field就要写id title: xxx //列名，显示的标题 formatter：function(value, row, index){ //对数据进行自定义,value表示对应field的数据，row表示这一行的内容，index表示序号，从0开始 return index + 1; //这样表示返回序号，从1开始，第2行2这样。可以在这对value处理再返回 } } ajax 自定义ajax方法,可以自己写ajax，不采用bootstrap的 queryParams 请求服务器后台的参数","categories":[{"name":"技术","slug":"技术","permalink":"https://xdong.me/categories/技术/"}],"tags":[{"name":"bootstrap","slug":"bootstrap","permalink":"https://xdong.me/tags/bootstrap/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xdong.me/categories/技术/"}]},{"title":"leetcode第4题：两个排序数组的中位数题解","slug":"leetcode第4题：两个排序数组的中位数题解","date":"2018-09-19T14:21:20.000Z","updated":"2019-08-25T11:23:17.322Z","comments":true,"path":"2018/09/19/leetcode第4题：两个排序数组的中位数题解/","link":"","permalink":"https://xdong.me/2018/09/19/leetcode第4题：两个排序数组的中位数题解/","excerpt":"","text":"简介做到第四题，感觉好难，复杂度O(log(m+n))不好做，觉得该二分，做了一个小时放弃了，感觉没大一大二那种一直做下去，几个小时都不放弃的精力了，也可能是天气太热…..索性看了看官方的题解，顿时感觉茅塞顿开，我就把那题解放到这来吧。原文链接 解决方案为了解决这个问题，我们需要理解“中位数的作用是什么”。在统计中，中位数被用来： 将一个集合划分为两个长度相等的子集，其中一个子集中的元素总是大于另一个子集中的元素。 如果理解了中位数的划分作用，我们就很接近答案了。 首先，让我们在任一位置 将 A 划分成两个部分： left_A | right_A A[0], A[1], ..., A[i-1] | A[i], A[i+1], ..., A[m-1] 由于 A 中有 m 个元素， 所以我们有 m+1 种划分的方法（i=0∼m）。 我们知道： len(left_A)=i,len(right_A)=m−i. 注意：当 i=0 时，left_A 为空集， 而当 i=m 时, right_A 为空集。 采用同样的方式，我们在任一位置 j 将 B 划分成两个部分： left_B | right_B B[0], B[1], ..., B[j-1] | B[j], B[j+1], ..., B[n-1] 将 left_A 和 left_B 放入一个集合，并将 rright_A 和 right_B 放入另一个集合。 再把这两个新的集合分别命名为 left_part 和 right_part： left_part | right_part A[0], A[1], ..., A[i-1] | A[i], A[i+1], ..., A[m-1] B[0], B[1], ..., B[j-1] | B[j], B[j+1], ..., B[n-1] 如果我们可以确认： 1.len(left_part)=len(right_part)2.max⁡(left_part)≤min⁡(right_part) 那么，我们已经将 {A,B} 中的所有元素划分为相同长度的两个部分，且其中一部分中的元素总是大于另一部分中的元素。那么： median=max(left_part)+min(right_part)​ / 2 要确保这两个条件，我们只需要保证： 1.i+j=m−i+n−j（或：m−i+n−j+1） 如果 n≥m，只需要使 i=0∼m, j=(m+n+1)/2−i2.B[j−1]≤A[i] 以及 A[i−1]≤B[j] ps.1 为了简化分析，我假设 A[i−1],B[j−1],A[i],B[j]总是存在，哪怕出现 i=0，i=m，j=0，或是 j=n 这样的临界条件。 我将在最后讨论如何处理这些临界值。 ps.2 为什么 n≥m？由于0≤i≤m且 j=(m+n+1)/2−i，我必须确保 j 不是负数。如果 n&lt;m，那么 j 将可能是负数，而这会造成错误的答案。 所以，我们需要做的是： 在 [0，m] 中搜索并找到目标对象 i，以使：B[j−1]≤A[i] 且 A[i−1]≤B[j],其中 j=(m+n+1)/2−i 接着，我们可以按照以下步骤来进行二叉树搜索： 设 imin=0，imax=m, 然后开始在 [imin,imax] 中进行搜索。令 i=(imin+imax)/2​， j=(m+n+1)/2−i 现在我们有 len(left_part)=len(right_part)。 而且我们只会遇到三种情况： B[j−1]≤A[i] 且 A[i−1]≤B[j]：这意味着我们找到了目标对象 i，所以可以停止搜索。 B[j−1]&gt;A[i]：这意味着 A[i] 太小，我们必须调整 i 以使 B[j−1]≤A[i]。我们可以增大 i 吗？是的，因为当 i 被增大的时候，j 就会被减小。因此 B[j−1] 会减小，而 A[i] 会增大，那么 B[j−1]≤A[i] 就可能被满足。我们可以减小 i 吗？不行，因为当 i 被减小的时候，j 就会被增大。因此 B[j−1] 会增大，而 A[i] 会减小，那么 B[j−1]≤A[i] 就可能不满足。所以我们必须增大 i。也就是说，我们必须将搜索范围调整为 [i+1,imax]。 因此，设imin=i+1并转到步骤 2。 A[i−1]&gt;B[j]： 这意味着 A[i−1] 太大，我们必须减小 i 以使 A[i−1]≤B[j]。 也就是说，我们必须将搜索范围调整为 [imin,i−1]。因此，设 imax=i−1，并转到步骤 2。 当找到目标对象 i 时，中位数为： max(A[i−1],B[j−1]), 当 m+n 为奇数时 max⁡(A[i−1],B[j−1])+min⁡(A[i],B[j])/2, ​, 当 m+n为偶数时 现在，让我们来考虑这些临界值 i=0,i=m,j=0,j=n，此时 A[i−1],B[j−1],A[i],B[j] 可能不存在。 其实这种情况比你想象的要容易得多。 我们需要做的是确保 max(left_part)≤min(right_part)。 因此，如果 i 和 j 不是临界值（这意味着 A[i−1],B[j−1],A[i],B[j]全部存在）, 那么我们必须同时检查 B[j−1]≤A[i] 以及 A[i−1]≤B[j] 是否成立。 但是如果 A[i−1],B[j−1],A[i],B[j] 中部分不存在，那么我们只需要检查这两个条件中的一个（或不需要检查）。 举个例子，如果 i=0，那么 A[i−1]不存在，我们就不需要检查 A[i−1]≤B[j] 是否成立。 所以，我们需要做的是： 在 [0，m] 中搜索并找到目标对象 i，以使：(j=0 or i=m or B[j−1]≤A[i]) 或是 (i=0 or j=n or A[i−1]≤B[j]), 其中 j=(m+n+1)/2−i 在循环搜索中，我们只会遇到三种情况： (j=0 or i=m or B[j−1]≤A[i])) 或是(i=0 or j=n or A[i−1]≤B[j])这意味着 i 是完美的，我们可以停止搜索。j&gt;0 and i&lt;m and B[j−1]&gt;A[i]这意味着 i 太小，我们必须增大它。i&gt;0 and j&lt;n and A[i−1]&gt;B[j]这意味着 i 太大，我们必须减小它。 class Solution { public double findMedianSortedArrays(int[] A, int[] B) { int m = A.length; int n = B.length; if (m &gt; n) { // to ensure m&lt;=n int[] temp = A; A = B; B = temp; int tmp = m; m = n; n = tmp; } int iMin = 0, iMax = m, halfLen = (m + n + 1) / 2; while (iMin &lt;= iMax) { int i = (iMin + iMax) / 2; int j = halfLen - i; if (i &lt; iMax &amp;&amp; B[j-1] &gt; A[i]){ iMin = i + 1; // i is too small } else if (i &gt; iMin &amp;&amp; A[i-1] &gt; B[j]) { iMax = i - 1; // i is too big } else { // i is perfect int maxLeft = 0; if (i == 0) { maxLeft = B[j-1]; } else if (j == 0) { maxLeft = A[i-1]; } else { maxLeft = Math.max(A[i-1], B[j-1]); } if ( (m + n) % 2 == 1 ) { return maxLeft; } int minRight = 0; if (i == m) { minRight = B[j]; } else if (j == n) { minRight = A[i]; } else { minRight = Math.min(B[j], A[i]); } return (maxLeft + minRight) / 2.0; } } return 0.0; } } 复杂度分析 时间复杂度：O(log⁡(min(m,n)))，首先，查找的区间是 [0,m]。 而该区间的长度在每次循环之后都会减少为原来的一半。 所以，我们只需要执行 log⁡(m) 次循环。由于我们在每次循环中进行常量次数的操作，所以时间复杂度为 O(log⁡(m))。 由于 m≤n，所以时间复杂度是 O(log⁡(min(m,n)))。 空间复杂度：O(1)， 我们只需要恒定的内存来存储 9 个局部变量， 所以空间复杂度为 O(1)。","categories":[{"name":"技术","slug":"技术","permalink":"https://xdong.me/categories/技术/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://xdong.me/tags/JAVA/"},{"name":"leetcode","slug":"leetcode","permalink":"https://xdong.me/tags/leetcode/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xdong.me/categories/技术/"}]},{"title":"排序算法总结","slug":"排序算法总结","date":"2018-09-18T14:04:38.000Z","updated":"2019-08-25T11:27:00.749Z","comments":true,"path":"2018/09/18/排序算法总结/","link":"","permalink":"https://xdong.me/2018/09/18/排序算法总结/","excerpt":"","text":"简介刷leetcode碰到一个难题，里面用到了分治法，想到了归并排序，觉得以前学的排序基本忘得差不多了，特别是快排，直接sort()调用，自己基本实现不了，索性重新复习一遍 归并排序简介归并排序(Merging Sort)就是将两个或两个以上的有序表合并成一个有序表的过程。将两个有序表合并成一个有序表的过程称为2-路归并，2-路归并最为简单和常用。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 算法思想假设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列的长度是１，然后两两归并，得到[n/2]个长度为2或１的有序子序列；再两两归并,…如此重复，直到得到一个长度为n的有序子序列为止。 用途1.排序：归并排序的时间复杂度是O(nlog2n)，当有n个记录时，需要进行log2n次归并排序，每一次归并，关键字比较次数不超过n，元素移动次数都是n，因此是nlog2n。归并排序是稳定排序(在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的)，可以用于链式结构。2.找逆序对数，以前打ACM碰到过好几次，第一次见到这种题觉得好难，这就说明对归并排序理解不深，这点在紫书上也提到过。当然也可以通过树状数组解决这类问题。 代码＋解释对于这张图，将原序列分解为n个子序列，然后开始比较归并，对于分解可以用二分＋递归来实现，合并也是一样。 //算法实现 //采用紫书代码 void merge_sort(int* A, int x, int y, int* T) { if(y - x &gt; 1) { int m = x + (y - x) / 2; //划分 int p = x, q = m, i = x; merge_sort(A, x, m, T); //递归求解 merge_sort(A, m, y, T); //递归求解 while(p &lt; m || q &lt; y) { if(q &gt;= y || (p &lt; m &amp;&amp; A[p] &lt;= A[q])) T[i++] = A[p++]; //从左半数组复制到临时空间 else T[i++] = A[q++]; //从右半数组复制到临时空间 // else T[i++] = A[q++], cnt += m - p; //这一行就可以实现求逆序对数的问题，其中cnt要先清零 } for(i = x; i &lt; y; i++) A[i] = T[i]; //从辅助空间复制回A数组 } }","categories":[{"name":"技术","slug":"技术","permalink":"https://xdong.me/categories/技术/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://xdong.me/tags/排序/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xdong.me/categories/技术/"}]},{"title":"UEFI启动模式的电脑安装Win10和Ubuntu双系统","slug":"UEFI启动模式的电脑安装Win10和Ubuntu双系统","date":"2018-03-22T16:00:00.000Z","updated":"2019-08-25T11:45:21.268Z","comments":true,"path":"2018/03/23/UEFI启动模式的电脑安装Win10和Ubuntu双系统/","link":"","permalink":"https://xdong.me/2018/03/23/UEFI启动模式的电脑安装Win10和Ubuntu双系统/","excerpt":"","text":"文章简介目前有很多教程安装Ubuntu，但大多数都比较老，而且步骤很繁琐，有的还是错的，偶然看到一篇文章写的很详细而且足够简洁，我获得作者授权后，将他的博文转载至此，原文链接，作者针叶。 教程双硬盘（固态+机械，并且原Windows的引导盘在固态）要装双系统，此文不适用（否则会出现安装完Ubuntu后看不到grub菜单或者搞出来grub菜单后看不到Windows Boot Manager选项，因为你把Ubuntu的引导装在了机械硬盘，和Win的引导不在一个盘），请移步大神们的文章：非UEFI：http://www.jianshu.com/p/c6750e459a94http://jingyan.baidu.com/article/e75aca8551621a142edac6db.html最后应该把固态硬盘分一部分出来作为Ubuntu的引导分区（因为下文所讲的是efi引导，最好不要挂载efi了，而是/boot）。 UEFI：通过BIOS设置切换硬盘启动顺序，以进入不同系统：http://www.cnblogs.com/willnote/p/6725594.html 我个人不太喜欢虚拟机下安装系统，一来运行效率不行，二来原生体验不行。 原本我的电脑是Windows 10专业版，为了体验和学习Linux，我给本本安装了Ubuntu 16.0.4 LTS（目前官网能下载到的最新版本），于是各种搜安装教程，感觉各种复杂。 后来我发现了他们复杂的原因，我仔细看了下这些教程文章的时间，很多都是好几年前的教程，就算是时间很近的，也是抄来抄去，长篇大论无奇不有。其实那都是因为以前的电脑都不是UEFI启动，而是Legacy，大家都知道Win8以后都有快速启动，必须得依靠UEFI。 然而随着UEFI的普及，现在你去买笔记本电脑几乎买不到不是UEFI的，这是一种先进安全的启动模式，而且Ubuntu本身也是支持UEFI启动的，所以安装双系统是非常简单的事情。 第一步最重要的就是你要分区，Linux没有什么C盘D盘的概念，只有分区挂载目录的概念，所以你在Windows下只需要分出一块较大的未分配空间就行，记住不要去格式化，保证其“未分配”属性（Linux的文件系统和Win是不一样的，NTFS和FAT32都不适用）。用Win自带的磁盘管理不能合并不相邻的未分配空间，所以你要想C盘割一点，D盘割一点，再合在一起那是不行的，解决办法是在WinPE系统环境下使用无损分区软件，去合并不同区域的空闲空间，这里不赘述。（如果不愿使用PE的，直接分割已有分区即可，比如你最后一个分区是F盘，分出几十个GB就行，当然前提是你原本空间够大） 第二，你必须要有一个U盘（光盘就算了太麻烦了），然后使用软碟通或者USBWriter把iso系统镜像文件烧录进去，这是比较传统的方法，但既然我们UEFI启动，那就根本不需要刻录这么麻烦的工作了，直接将iso里的所有文件解压至U盘即可。大家可以看到，Ubuntu的镜像文件里本身就有EFI文件夹，说明其实支持UEFI引导安装的。 然后记得关闭Windows的快速启动，重启电脑，我是Dell的本，开机按F2进入BIOS设置，F12进入启动设置，其它电脑类似，大家自行了解。 进入BIOS设置后，关闭Security Boot（我这里Dell的本是按F12，再选最后那个Change Mode……，然后改为UEFI, Security Boot Off），最后选择UEFI下的U盘启动，所以整个过程根本不用改为Legacy里的HardDisk启动，那是个既老又慢的启动方式。 选中USB启动，回车后即进入Ubuntu安装流程，前面几步我就不说了，按照正常的步骤，如果你选择了安装更新和第三方软件，那么一定要记得联网，否则会卡死在最后的进度条上，所以最好不要勾选。另外，不要选择“与其它系统共存”那一项，而选择最后那个“其它选项（创建自己的分区）”。 最最最关键的就是分区这一步，这一步直接影响你安装双系统是否成功！下面依次点击新建分区表来挂载分区。 swap交换空间，这个也就是虚拟内存的地方，选择主分区和空间起始位置。如果你给Ubuntu系统分区容量足够的话，最好是能给到你物理内存的2倍大小，像我8GB内存，就可以给个16GB的空间给它，这个看个人使用情况，太小也不好，太大也没用。（其实我只给了8GB，没什么问题） 新建efi系统分区，选中逻辑分区（这里不是主分区，请勿怀疑，老式的boot挂载才是主分区）和空间起始位置，大小最好不要小于256MB，系统引导文件都会在里面，我给的512MB，它的作用和boot引导分区一样，但是boot引导是默认grub引导的，而efi显然是UEFI引导的。不要按照那些老教程去选boot引导分区，也就是最后你的挂载点里没有“/boot”这一项，否则你就没办法UEFI启动两个系统了。 挂载“/home”，类型为EXT4日志文件系统，选中逻辑分区和空间起始位置，这个相当于你的个人文件夹，类似Windows里的User，如果你是个娱乐向的用户，我建议最好能分配稍微大点，因为你的图片、视频、下载内容基本都在这里面，这些东西可不像在Win上面你想移动就能移动的。总的来说，最好不要低于8GB，我Ubuntu分区的总大小是64GB，这里我给了12GB给home。（这里特别提醒一下，Ubuntu最新发行版不建议强制获取Root权限，因为我已经玩崩过一次。所以你以后很多文档、图片、包括免安装软件等资源不得不直接放在home分支下面。你作为图形界面用户，只对home分支有完全的读写执行权限，其余分支例如usr你只能在终端使用sudo命令来操作文件，不利于存放一些直接解压使用的免安装软件。因此，建议home分支多分配一点空间，32GB最好……） 挂载“/usr”，类型为EXT4日志文件系统，选中逻辑分区和空间起始位置，这个相当于你的软件安装位置，Linux下一般来说安装第三方软件你是没办法更改安装目录的，系统都会统一地安装到/usr目录下面，因此你就知道了，这个分区必须要大，我给了32GB。 最后，挂载“/”，类型为EXT4日志文件系统，选中逻辑分区和空间起始位置，因为除了home和usr还有很多别的目录，但那些都不是最重要的，“/”就把除了之前你挂载的home和usr外的全部杂项囊括了，大小也不要太小，最好不低于8GB。如果你非要挨个仔细分配空间，那么你需要知道这些各个分区的含义（Linux(ubuntu)分区挂载点介绍）不过就算你把所有目录都自定义分配了空间也必须要给“/”挂载点分配一定的空间。 分配好各个挂载点后，还有一个至关重要的步骤，那就是选择“安装引导启动器的设备”，默认是错&gt;误的，既然我们为Ubuntu分配了efi系统引导分区，那么显然，这里应该把它改成刚刚第2步分配efi引&gt;导的那个分区（比如我安装时它是/dev/sda7，那么我就选这个）。 如此一来，成功一大半，接下来点击安装，等待差不多半小时即可。这个就看电脑配置和网速了。 这里再多说一句，如果你安装进度条卡在最后的update-notifier-common，请拔掉你的网线也就是断网，然后再连接，多等一会儿就会好。你点一下那行字就会看到安装详情，只要详情在刷新就没问题。 安装成功后，会提示你拔掉U盘并且重启，重启后记得进入BIOS改回UEFI Security Boot On模式，也就是重新开启Security Boot，然后再重启你就可以看到选择系统的启动引导界面了，一般来说：第一个是Ubuntu，选这个进入Ubuntu系统，第二个是Ubuntu高级选项，第三个是Windows Boot Manager，也就是启动你的Win10，第四个不好意思忘了。 默认10s自动进入第一个，如果你不动的话。以上教程比网上一些图文更系统更有用，只要你耐心看完，保证万无一失。安装成功后，Win10的快速启动也可以重新开启。 最最最后，如果大家装好系统后想要恢复U盘到普通状态的话，请看我的另一篇博文：解决U盘制作Ubuntu系统安装盘后无法格式化且容量无法恢复。","categories":[{"name":"转载","slug":"转载","permalink":"https://xdong.me/categories/转载/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://xdong.me/tags/Ubuntu/"},{"name":"Win10","slug":"Win10","permalink":"https://xdong.me/tags/Win10/"}],"keywords":[{"name":"转载","slug":"转载","permalink":"https://xdong.me/categories/转载/"}]},{"title":"简单点餐app的实现","slug":"简单点餐app的实现","date":"2017-12-29T16:00:00.000Z","updated":"2019-08-25T11:28:26.123Z","comments":true,"path":"2017/12/30/简单点餐app的实现/","link":"","permalink":"https://xdong.me/2017/12/30/简单点餐app的实现/","excerpt":"","text":"简介这学期开了学Android的课，以前也没看过相关的知识，刚好前两周课设用来检验一下学习的成果，就做了一个点餐的app，实现了和服务器后台的交互，数据库用的mysql，用户使用app，商家使用web页面，由于自己弱渣，用了很多别人的设计和代码，如有侵权，请联系我。 APP设计Android第一次学，代码写的很乱，请不要介意。 Abdroid项目源码（后台源码在下面） 界面展示这是主要的界面，还有一些展示订单的界面，有一些没用的特效界面。。 设计简要第一次做，写的乱七八糟，基本一个页面一个Activity，底部菜单栏用的Tabhost+Activity实现，有些设计用的github上的代码，由于和服务器交互，读取的是数据库的内容，所以Listview使用最频繁，每加载一个页面都会get/post服务器，对于网络延迟的问题就加了一个Dialog等待加载。java部分写的比较乱，将就着看吧。。 使用注意Github项目中包含了apk文件，可以直接拿来用，不过服务器是我自己的，现在快到期了，可能停止服务。你也可以把后台部署到自己的服务器上来使用，因为后台是用java写的，所以用Tomcat来用就可以。 如果使用自己的服务器，就要到Android项目中app\\src\\main\\java\\com\\example\\user\\util\\Data.java 中修改自己的域名或者说ip，这样就可以访问你自己服务器的数据了。war文件和mysql数据库的创建文件也在后台项目中，源码地址在下面。 其中mysql中图片存储使用的都是外链，你可以使用七牛云，腾讯云，或者其他可提供图片外链的服务。其他数据可以通过商家web界面添加或者直接对数据库操作。 后台实现大二学的java，自己学了一点点java web的知识，这次课设拿来练手，就用eclipse写了后台部署到服务器上，代码稍微比Android好看一些。和app的交互用的servlet接收发送json信息。然后对数据库进行增删改查，实现完整的操作。 mysql的连接在util类里，可以修改mysql的密码和用户名等等。 后台项目源码 界面浏览器访问界面实现商家的注册和登录，可以对自己店铺的菜品类别等等进行修改，也可以实现接单删除等功能，其他的自己去看。 设计简要 util包含数据库连接和json的解析 servlet是对app的连接 action里面写了web页面的servlet，实现店铺数据的增删改查 model写了数据库中表的信息，get+set dao+imp实现增删改查的具体操作 使用注意我写的时候eclipse myeclipse都使用过，直接导入自己的IDE可能出很多问题，慢慢百度或者各种调整说不定能解决，那就可以修改了 web页面用的jsp，也可以直接看，简单的操作都实现了，具体的自己研究。 总结如果有什么问题可以直接联系我，或者说有错也可以提出，修改和测试才是漫长的过程。","categories":[{"name":"技术","slug":"技术","permalink":"https://xdong.me/categories/技术/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://xdong.me/tags/JAVA/"},{"name":"Android","slug":"Android","permalink":"https://xdong.me/tags/Android/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xdong.me/categories/技术/"}]},{"title":"随笔：递归的妙用<1>","slug":"随笔：递归的妙用-1","date":"2017-12-08T16:00:00.000Z","updated":"2019-08-25T11:29:01.697Z","comments":true,"path":"2017/12/09/随笔：递归的妙用-1/","link":"","permalink":"https://xdong.me/2017/12/09/随笔：递归的妙用-1/","excerpt":"","text":"起因昨天闲的蛋疼在百度知道回答问题，看到一个很有趣的题目，要求用递归实现如下的输出 15 28 6 310 9 7 4 想了一段时间， 自己写了个代码，差不多实现了这功能，却又懒得去优化一下。好久没做算法题目lower_bound的参数都记得不太清楚了，不过还好自己写出来的没错，程序成功运行。 代码+结果 代码如下 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;cstdlib&gt; #include &lt;set&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #include &lt;map&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;cctype&gt; #define LL long long using namespace std; const LL inf = 1e18; const LL mod = 1e9+7; int s[10] = {1, 3, 6, 10, 15, 21, 27}; int m; void f(int n, int k, int cnt) { if(n == 1) { return; } else if(cnt == 0) { cnt = m - k - 1; k = m; f(cnt + 1, k, cnt); printf(&quot;%d\\n&quot;, cnt + 1); }else { f(n + k, k - 1, cnt - 1); printf(&quot;%d &quot;, n + k); } } int main() { //1 3 6 10 15 21 27 //1 2 3 4 5 6 7 //s = (1 + n) * n / 2 int n; while(scanf(&quot;%d&quot;, &amp;n) != EOF) { int k = lower_bound(s, s + 7, n) - s; m = k; f(k + 1, k, k); printf(&quot;%d\\n&quot;, k + 1); } return 0; } 结果如图 小结有时间做做这类型的题目也很有意思，锻炼一下思维还是有好处的，这个写的比较烂，如果有更好的方法，不如说出来大家共同探讨一下。","categories":[{"name":"技术","slug":"技术","permalink":"https://xdong.me/categories/技术/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://xdong.me/tags/递归/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xdong.me/categories/技术/"}]},{"title":"JAVA实现微信支付","slug":"JAVA实现微信支付","date":"2017-11-21T08:39:04.000Z","updated":"2019-08-25T11:22:32.172Z","comments":true,"path":"2017/11/21/JAVA实现微信支付/","link":"","permalink":"https://xdong.me/2017/11/21/JAVA实现微信支付/","excerpt":"","text":"前言前段时间在做一个微信公众号，需要用到微信支付的接口，第一次用，果然和前面写其他接口经历一样，好繁琐的操作。去找了相关资料，看了看文档，越看越复杂，大多数博客上面的总是缺着一部分跑不起来，官方demo又好复杂，索性自己好好搞一次。 需求准备1.首先一个公众号（服务号），也可以企业号，订阅号没有支付权限（权限可以查文档），可以去微信公众平台申请，而且需要认证，一年3002.一个域名，必须经过ICP备案，必须备案，很重要，也就是说还需要一个服务器，备案大概1个月3.微信支付开发文档4.商户平台账号，也就是微信支付平台，前段时间微信支付单独迁移到了商户平台，所以需要单独申请 实现过程1.前提公众号的配置已经完成，比如在公众平台的服务器配置，接口域名配置，授权配置等等。还有商户平台的支付授权目录填写。这些都可以通过文档或者搜索引擎找到。2.接下来需要调用统一下单接口获取预支付id（prepay_id）其中需要很多参数，参数的具体含义可见文档这是签名生成算法大多数错误都是由于签名错误 //微信支付 String nonceStr = &quot;2D8264ILTKCH16CQ2502SI8ZNMTM67VS&quot;;//随机字符串,可以自己生成 String MCHID = &quot;11111111&quot;; //商户号，商户平台注册 String WX_APPID = ; //APPID，也就是公众平台APPID String body = &quot;xx&quot;; //商品描述 String WX_PAY_CALLBACK = &quot;&quot;;//异步接收微信支付结果通知的回调地址 String ip = request.getRemoteAddr(); //用户端ip String orderSn = String.valueOf((int)(new Date().getTime()));//商户订单号,这用的是时间 String relAmount = 1;//订单总金额，单位为分 String openid = user.getOpenid(); //用户openid String key = &quot;&quot;; //商户平台API秘钥 // 加密，这里只列举必填字段 Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put(&quot;body&quot;, body);//商品描述 map.put(&quot;mch_id&quot;, MCHID);//商户平台id map.put(&quot;appid&quot;, WX_APPID);//公众号id map.put(&quot;nonce_str&quot;, nonceStr);//随机字符串 map.put(&quot;notify_url&quot;, WX_PAY_CALLBACK);//异步回调api map.put(&quot;spbill_create_ip&quot;, ip);//支付ip map.put(&quot;out_trade_no&quot;, orderSn);//商品订单号 map.put(&quot;total_fee&quot;, relAmount);//真实金额 map.put(&quot;trade_type&quot;, &quot;JSAPI&quot;);//JSAPI、h5调用 map.put(&quot;openid&quot;, openid);//支付用户openid String paySign = &quot;&quot;; try { paySign = WeixinUtil.getPayCustomSign(map,key);//WeixinUtil类会在下面展示 //这一句是签名生成算法 } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); } map.put(&quot;sign&quot;,paySign); System.out.println(&quot;sign &quot; + paySign); String xml = &quot;&lt;xml&gt;&quot; + &quot;&lt;appid&gt;&quot;+ WX_APPID +&quot;&lt;/appid&gt;&quot;+ &quot;&lt;body&gt;&quot;+ body +&quot;&lt;/body&gt;&quot;+ &quot;&lt;mch_id&gt;&quot;+ MCHID +&quot;&lt;/mch_id&gt;&quot;+ &quot;&lt;nonce_str&gt;&quot;+ nonceStr +&quot;&lt;/nonce_str&gt;&quot;+ &quot;&lt;notify_url&gt;&quot;+ WX_PAY_CALLBACK +&quot;&lt;/notify_url&gt;&quot;+ &quot;&lt;openid&gt;&quot;+ openid +&quot;&lt;/openid&gt;&quot;+ &quot;&lt;out_trade_no&gt;&quot;+ orderSn +&quot;&lt;/out_trade_no&gt;&quot;+ &quot;&lt;spbill_create_ip&gt;&quot;+ ip +&quot;&lt;/spbill_create_ip&gt;&quot;+ &quot;&lt;total_fee&gt;&quot;+ relAmount + &quot;&quot; +&quot;&lt;/total_fee&gt;&quot;+ &quot;&lt;trade_type&gt;JSAPI&lt;/trade_type&gt;&quot;+ &quot;&lt;sign&gt;&quot;+ paySign +&quot;&lt;/sign&gt;&quot;+ &quot;&lt;/xml&gt;&quot;; System.out.println(xml); //将map转为XML格式 //统一下单，这里不用改 String url = &quot;https://api.mch.weixin.qq.com/pay/unifiedorder&quot;; //统一下单接口 String xmlStr = WeixinUtil.post(url, xml); //post请求数据 System.out.println(xmlStr); String prepayid = &quot;&quot;; if (xmlStr.indexOf(&quot;SUCCESS&quot;) != -1) { Map&lt;String, String&gt; map2 = null; try { map2 = WeixinUtil.xmlToMap(xmlStr); } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); } prepayid = (String) map2.get(&quot;prepay_id&quot;); //获取prepayid System.out.println(&quot;prepay_id &quot; + prepayid); 现在如果返回了prepay id，那么这一步就算完成，如果出现错误，一般都是签名出错，这时候就要好好看看有没有语法错误，或者签名算法有误。 3.第二次签名，然后传值到前端 long timestamp = System.currentTimeMillis() / 1000; //时间戳 Map&lt;String, String&gt; signMap = new HashMap&lt;String, String&gt;(); signMap.put(&quot;appId&quot;, WX_APPID);//appid signMap.put(&quot;timeStamp&quot;, String.valueOf(timestamp)); signMap.put(&quot;nonceStr&quot;, nonceStr); signMap.put(&quot;package&quot;, &quot;prepay_id=&quot;+prepayid); signMap.put(&quot;signType&quot;, &quot;MD5&quot;); String paySign2 = &quot;&quot;; try { paySign2 = WeixinUtil.getPayCustomSign(signMap,key); System.out.println(paySign2); } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); } System.out.println(&quot;timestamp&quot; + timestamp); //以下的数据需要传到前端，可以用自己的方法传值 request.setAttribute(&quot;appId&quot;, WX_APPID); request.setAttribute(&quot;paytimestamp&quot;, String.valueOf(timestamp)); request.setAttribute(&quot;paynonceStr&quot;, nonceStr); request.setAttribute(&quot;paypackage&quot;, &quot;prepay_id=&quot;+prepayid); request.setAttribute(&quot;paysignType&quot;,&quot;MD5&quot;); request.setAttribute(&quot;paySign&quot;, paySign2); //去到确认支付页面,返回页面方式不同,(例：pay.html页面) 4.H5调用微信支付接口 官方文档内含代码只需把参数改为自己的，调用接口就可以完成支付 5.我用到的WeixinUtil类，只是写了用到的一部分，导入的包可能很多没用。。 import java.io.ByteArrayInputStream; import java.io.IOException; import java.io.InputStream; import java.io.UnsupportedEncodingException; import java.net.URLEncoder; import java.security.MessageDigest; import java.sql.Timestamp; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.Comparator; import java.util.Date; import java.util.HashMap; import java.util.List; import java.util.Map; import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import org.apache.http.HttpEntity; import org.apache.http.HttpResponse; import org.apache.http.client.ClientProtocolException; import org.apache.http.client.methods.HttpGet; import org.apache.http.client.methods.HttpPost; import org.apache.http.entity.StringEntity; import org.apache.http.impl.client.DefaultHttpClient; import org.apache.http.util.EntityUtils; import org.w3c.dom.Node; import org.w3c.dom.NodeList; import org.xmlpull.v1.XmlPullParser; import org.xmlpull.v1.XmlPullParserException; import org.xmlpull.v1.XmlPullParserFactory; import net.sf.json.JSONObject; public class WeixinUtil { private static final String hexDigits[] = { &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot; }; public static String post(String url,String outStr){ DefaultHttpClient httpClient = new DefaultHttpClient(); HttpPost httpPost = new HttpPost(url); String res =null; try { httpPost.setEntity(new StringEntity(outStr, &quot;utf-8&quot;)); HttpResponse response = httpClient.execute(httpPost); String result = EntityUtils.toString(response.getEntity(),&quot;utf-8&quot;); res = result; } catch (UnsupportedEncodingException e) { e.printStackTrace(); } catch (ClientProtocolException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return res; } /** * 获取支付所需签名 */ public static String getPayCustomSign(Map&lt;String, String&gt; bizObj,String key) throws Exception { String bizString = FormatBizQueryParaMap(bizObj, false); return sign(bizString, key); } //支付所需签名处调用此方法 public static String sign(String content, String key) throws Exception{ String signStr = &quot;&quot;; signStr = content + &quot;&amp;key=&quot; + key; return MD5(signStr).toUpperCase(); } //上一方法，MD5加密处理 public final static String MD5(String s) { char hexDigits[]={&#39;0&#39;,&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;,&#39;6&#39;,&#39;7&#39;,&#39;8&#39;,&#39;9&#39;,&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;}; try { byte[] btInput = s.getBytes(); MessageDigest mdInst = MessageDigest.getInstance(&quot;MD5&quot;); mdInst.update(btInput); byte[] md = mdInst.digest(); int j = md.length; char str[] = new char[j * 2]; int k = 0; for (int i = 0; i &lt; j; i++) { byte byte0 = md[i]; str[k++] = hexDigits[byte0 &gt;&gt;&gt; 4 &amp; 0xf]; str[k++] = hexDigits[byte0 &amp; 0xf]; } return new String(str); } catch (Exception e) { e.printStackTrace(); return null; } } /** * 字典排序 */ public static String FormatBizQueryParaMap(Map&lt;String, String&gt; paraMap, boolean urlencode) throws Exception { String buff = &quot;&quot;; try { List&lt;Map.Entry&lt;String, String&gt;&gt; infoIds = new ArrayList&lt;Map.Entry&lt;String, String&gt;&gt;(paraMap.entrySet()); Collections.sort(infoIds, new Comparator&lt;Map.Entry&lt;String, String&gt;&gt;() { public int compare(Map.Entry&lt;String, String&gt; o1, Map.Entry&lt;String, String&gt; o2) { return (o1.getKey()).toString().compareTo( o2.getKey()); } }); for (int i = 0; i &lt; infoIds.size(); i++) { Map.Entry&lt;String, String&gt; item = infoIds.get(i); //System.out.println(item.getKey()); if (item.getKey() != &quot;&quot;) { String key = item.getKey(); String val = item.getValue(); if (urlencode) { val = URLEncoder.encode(val, &quot;utf-8&quot;); } buff += key + &quot;=&quot; + val + &quot;&amp;&quot;; } } if (buff.isEmpty() == false) { buff = buff.substring(0, buff.length() - 1); } } catch (Exception e) { throw new Exception(e.getMessage()); } return buff; } public static Map&lt;String, String&gt; xmlToMap(String strXML) throws Exception { try { Map&lt;String, String&gt; data = new HashMap&lt;String, String&gt;(); DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder(); InputStream stream = new ByteArrayInputStream(strXML.getBytes(&quot;UTF-8&quot;)); org.w3c.dom.Document doc = documentBuilder.parse(stream); doc.getDocumentElement().normalize(); NodeList nodeList = doc.getDocumentElement().getChildNodes(); for (int idx = 0; idx &lt; nodeList.getLength(); ++idx) { Node node = nodeList.item(idx); if (node.getNodeType() == Node.ELEMENT_NODE) { org.w3c.dom.Element element = (org.w3c.dom.Element) node; data.put(element.getNodeName(), element.getTextContent()); } } try { stream.close(); } catch (Exception ex) { // do nothing } return data; } catch (Exception ex) { //WXPayUtil.getLogger().warn(&quot;Invalid XML, can not convert to map. Error message: {}. XML content: {}&quot;, ex.getMessage(), strXML); throw ex; } } } 总结官方文档写的比较难懂，其他的又比较杂，有的不能用，当然也可以github找demo，这也是我第一次做这些，写的很难看不要在意，如果有错的地方希望提出来，欢迎指导交流。","categories":[{"name":"技术","slug":"技术","permalink":"https://xdong.me/categories/技术/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://xdong.me/tags/JAVA/"},{"name":"微信支付","slug":"微信支付","permalink":"https://xdong.me/tags/微信支付/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xdong.me/categories/技术/"}]},{"title":"微信公众号带参二维码的生成与解析（java)","slug":"微信公众号带参二维码的生成与解析","date":"2017-10-01T16:00:00.000Z","updated":"2019-08-25T11:25:54.867Z","comments":true,"path":"2017/10/02/微信公众号带参二维码的生成与解析/","link":"","permalink":"https://xdong.me/2017/10/02/微信公众号带参二维码的生成与解析/","excerpt":"","text":"这些日子一直在做微信公众号的开发，从头开始学，觉得特别复杂，接口一堆，开发文档看不懂，各种bug，由于现在二维码的广泛流传，接触了带参二维码，写一下生成与解析 带参二维码介绍为了满足我们这些用户的需要，公众平台提供了生成带参数二维码的接口。使用该接口可以获得多个带不同场景值的二维码，用户扫描后，公众号可以接收到事件推送。说白了就是可以生成带参数的二维码，后台可以根据参数做出不同的反应，然后推送信息给用户，使一些操作简单化。 目前有2种类型的二维码，分别是临时二维码和永久二维码，前者有过期时间，但能够生成较多数量，后者无过期时间，数量较少（目前参数只支持1–100000），而且参数只能是整数。 用户扫描带场景值二维码时，可能推送以下两种事件：如果用户还未关注公众号，则用户可以关注公众号，关注后微信会将带场景值关注事件推送给开发者。如果用户已经关注公众号，在用户扫描后会自动进入会话，微信也会将带场景值扫描事件推送给开发者。 带参二维码的生成1.首先创建二维码ticket，然后凭借ticket到指定URL换取二维码2.然后会返回一个链接，打开就是一个二维码 当然这些前提就是有公众号并且前期的开发配置已完成，服务器域名什么的都配好了，也认证了，或者用的测试号都可以 创建二维码ticket需要提供一个开发者自行设定的参数（scene_id），这个就是所谓的参数（整数） http请求URLhttps://api.weixin.qq.com/cgi-bin/qrcode/create?access_token=TOKEN POST数据格式(临时二维码) { “expire_seconds”: 1800,”action_name”: “QR_SCENE”,”action_info”: {“scene”: {“scene_id”: 100000}}} 其中expire_seconds就是存在的时间，action_name确定二维码是永久的还是临时的，详细参数的可以看微信开发文档。 返回格式：（临时二维码) {“ticket”:”gQFK8DoAAAAAAAAAASxodHRwOi8vd2VpeGluLnFxLmNvbS9xL3kweXE0T3JscWY3UTltc3ZPMklvAAIEG9jUUgMECAcAAA==”,”expire_seconds”: 1800} 代码: JSONObject tjsonObj = getTicketJsonObj(6,604800); String ticketString = tjsonObj.getString(&quot;ticket&quot;); int expire_seconds = tjsonObj.getInt(&quot;expire_seconds&quot;); String url = tjsonObj.getString(&quot;url&quot;); System.out.println(&quot;ticketString:&quot;+ticketString); System.out.println(&quot;expire_seconds:&quot;+expire_seconds); System.out.println(&quot;url:&quot;+url); String qrcodeUrl = getQrcodeUrl(tjsonObj); System.out.println(&quot;qrcodeUrl:&quot;+qrcodeUrl); public static JSONObject getTicketJsonObj(int scene_id,int expire_seconds){ StringBuffer ticket = new StringBuffer(); ticket.append(&quot;{\\&quot;expire_seconds\\&quot;:&quot;); ticket.append(Integer.toString(expire_seconds)); ticket.append(&quot;,\\&quot;action_name\\&quot;:\\&quot;QR_SCENE\\&quot;,&quot;); ticket.append(&quot;\\&quot;action_info\\&quot;:{\\&quot;scene\\&quot;:{\\&quot;scene_id\\&quot;:&quot;); ticket.append(Integer.toString(scene_id)); ticket.append(&quot;}}}&quot;); AccessTokenDao atDao = new AccessTokenDao(); atDao.checkToken(); String token = atDao.getAccessTokenBySQL().getToken(); String url = TICKET_URL.replace(&quot;TOKEN&quot;, token); String ticket1 = new String(ticket); return doPostStr(url, ticket1); } public static JSONObject doPostStr(String url,String outStr){ DefaultHttpClient httpClient = new DefaultHttpClient(); HttpPost httpPost = new HttpPost(url); JSONObject jsonObject =null; try { httpPost.setEntity(new StringEntity(outStr, &quot;utf-8&quot;)); HttpResponse response = httpClient.execute(httpPost); String result = EntityUtils.toString(response.getEntity(),&quot;utf-8&quot;); jsonObject = JSONObject.fromObject(result); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } catch (ClientProtocolException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return jsonObject; } public static String getQrcodeUrl(JSONObject ticketObj){ String ticketString = ticketObj.getString(&quot;ticket&quot;); String url =null; try { url = QRCODE_URL.replace(&quot;TICKET&quot;, URLEncoder.encode(ticketString,&quot;utf-8&quot;)); } catch (UnsupportedEncodingException e) { // TODO Auto-generated catch block e.printStackTrace(); } return url; } 现在就得到了url，打开就是二维码的图片 带参二维码的解析微信公众平台推送的消息一般是xml来做的。用户扫描带场景值二维码时，可能推送以下两种事件：如果用户还未关注公众号，则用户可以关注公众号，关注后微信会将带场景值关注事件推送给开发者。如果用户已经关注公众号，则微信会将带场景值扫描事件推送给开发者。 用户未关注时，进行关注后的事件推送&lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[gh_45072270791c]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[o7Lp5t6n59DeX3U0C7Kric9qEx-Q]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;1389684286&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[event]]&gt;&lt;/MsgType&gt; &lt;Event&gt;&lt;![CDATA[subscribe]]&gt;&lt;/Event&gt; &lt;EventKey&gt;&lt;![CDATA[qrscene_1000]]&gt;&lt;/EventKey&gt; &lt;Ticket&gt;&lt;![CDATA[gQHi8DoAAAAAAAAAASxodHRwOi8vd2VpeGluLnFxLmNvbS9xL0UweTNxNi1sdlA3RklyRnNKbUFvAAIELdnUUgMEAAAAAA==]]&gt;&lt;/Ticket&gt; &lt;/xml&gt; 其中EventKey包括参数。 用户已关注时的事件推送 &lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[gh_45072270791c]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[o7Lp5t6n59DeX3U0C7Kric9qEx-Q]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;1389684184&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[event]]&gt;&lt;/MsgType&gt; &lt;Event&gt;&lt;![CDATA[SCAN]]&gt;&lt;/Event&gt; &lt;EventKey&gt;&lt;![CDATA[1000]]&gt;&lt;/EventKey&gt; &lt;Ticket&gt;&lt;![CDATA[gQHi8DoAAAAAAAAAASxodHRwOi8vd2VpeGluLnFxLmNvbS9xL0UweTNxNi1sdlA3RklyRnNKbUFvAAIELdnUUgMEAAAAAA==]]&gt;&lt;/Ticket&gt; &lt;/xml&gt; 然后就可以解析这些事件，来做出响应。 public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.setCharacterEncoding(&quot;utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); PrintWriter out = response.getWriter(); try { Map&lt;String, String&gt; map = MessageUtil.xmlToMap(request); String toUserName = map.get(&quot;ToUserName&quot;); String fromUserName = map.get(&quot;FromUserName&quot;);// openid String msgType = map.get(&quot;MsgType&quot;); String content = map.get(&quot;Content&quot;); String message = null; if (MessageUtil.MESSAGE_TEXT.equals(msgType)) { } } else if (MessageUtil.MESSAGE_EVENT.equals(msgType)) { } } catch (DocumentException e) { e.printStackTrace(); } finally { out.close(); } } 自己可以做一些相关的功能实现或者返回消息给用户 代码部分是网上的，部分是自己的，写的不好，只是一个大概的方法步骤。如有错误，希望指出","categories":[{"name":"技术","slug":"技术","permalink":"https://xdong.me/categories/技术/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://xdong.me/tags/JAVA/"},{"name":"微信公众号","slug":"微信公众号","permalink":"https://xdong.me/tags/微信公众号/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xdong.me/categories/技术/"}]},{"title":"推荐几个有趣的网址","slug":"推荐几个有趣的网址","date":"2017-09-11T16:00:00.000Z","updated":"2019-08-25T11:27:47.022Z","comments":true,"path":"2017/09/12/推荐几个有趣的网址/","link":"","permalink":"https://xdong.me/2017/09/12/推荐几个有趣的网址/","excerpt":"","text":"这是在网上发现的一些有趣的网址 1 http://virtocean.com/可以在线倾听海洋里的各种声音,配着3D的海洋效果 2 http://upuptoyou.com/这个可以输入一些字符（汉字），生成一张小人举牌的图片 3 http://lights.helloenjoy.com/一个特别绚丽的网页，如同一个mv 4 https://cn.codecombat.com/play一个游戏网站，但不同的是可以学习编程，在打游戏的过程顺便学学python 5 https://www.jiumodiary.com/一个搜索电子书的网站，提供很多格式，作为小说爱好者不妨看看 6 http://glench.com/hash/#CLICK一个很魔性的网站，点开看看地址栏你会明白的，重点是地址栏 7 http://makeagif.com/这个该收藏的，可以在线将视频转换为gif,youtube视频转换GIF最为方便,直接将链接复制就行 8 http://produckhunt.co/打鸭子游戏，不过这个是手机电脑同步，拿手机当做枪 9 https://cn.office-converter.com/在线文件格式转换，支持很多文档格式互换 10 http://race.assassinscreedpirates.com/网页版的刺客信条","categories":[{"name":"资源","slug":"资源","permalink":"https://xdong.me/categories/资源/"}],"tags":[{"name":"网址","slug":"网址","permalink":"https://xdong.me/tags/网址/"}],"keywords":[{"name":"资源","slug":"资源","permalink":"https://xdong.me/categories/资源/"}]},{"title":"hexo+github搭建自己博客（绑定域名）","slug":"hexo+github搭建自己的博客","date":"2017-09-08T16:00:00.000Z","updated":"2019-08-25T11:22:15.924Z","comments":true,"path":"2017/09/09/hexo+github搭建自己的博客/","link":"","permalink":"https://xdong.me/2017/09/09/hexo+github搭建自己的博客/","excerpt":"","text":"一直有些荒废，以前就想做个博客，但服务器贵不说，现在备案贼麻烦，后来知道GitHub上面可以做，用hexo或者Jekyll，我就用hexo+github 做了个博客，当然是用的别人摸板。。 安装git先要安装git，下载地址然后安装，基本上是一直默认next，其中在这选第二个 一路默认安装完成 安装node.jshexo是一款基于Node.js的静态博客框架，需要配置node.js的环境下载地址安装时一路默认就可以 申请github账号,配置git个人信息已有账号的的而且SSH keys配置的可以跳过当然也可以自己百度/谷歌，可能更详细1.设置Git的user name和email git config –global user.name “” (引号里面填)git config –global user.email “” 2.生成密钥 SSH keys ssh-keygen -t rsa -C “邮箱” 按3个回车，密码为空，最后得到了两个文件：id_rsa和id_rsa.pub，存放路径一般：c:/Users/xxxx_000/.ssh/ 3.注册github账号，这个自己可以吧 4.登录github，点头像-&gt;Settings-&gt;SSH kyes-&gt;Add SSH key。打开id_rsa.pub文件，全选复制公钥内容,将公钥粘贴到GitHub中Add an SSH key的key输入框，最后“Add Key”。 5.测试ssh keys是否设置成功。 ssh -T git@github.com 输入yes, 如果出现Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access. 说明设置成功。 安装hexo1.创建文件夹，在哪都行，名字最好blog或者hexo什么的2.在文件下，右键运行Git Bash安装hexo sudo npm install -g hexo 初始化hexo hexo init 现在已经安装完成，这个文件就是博客根目录，所有操作都在这里面 找一些主题，也可以克隆找到喜欢的主题后放到themes文件下生成静态页面 hexo generate（hexo g也可以） 本地启动启动本地服务，进行文章预览调试，命令： hexo server (hexo s) 浏览器输入http://localhost:4000就可以本地查看博客 配置到github上github上面新建一个仓库new repository，仓库名必须为【your_user_name.github.io】，例如 Hiccup1.github.io 现在打开config.yml文件（自己建的文件夹下），来建立关联翻到下面改成这个样子注意冒号前面有空格然后执行命令： npm install hexo-deployer-git –save 接下来就可以发布到github上面 hexo deploy(hexo d) 一般指令就是 hexo cleanhexo g (生成静态文件)hexo s (启动本地服务,可以http://localhost:4000本地查看)hexo d (发布到github上) 这时候就可以访问自己博客http://Hiccup1.github.io (改成你自己的) 如果自己有域名，可以绑定为自己域名要将域名解析到github的地址（就是Hiccup1.github.io地址，你也可以ping自己的xx.github.io） 点击settings 翻到下面,填上去，保存 也可以在根目录/source 目录下创建一个新文件CNAME(不带任何后缀)，直接在CNAME文件中写上自己的域名 hexo ghexo d 就可以了 杂项写博客可以用Markdown 主题可以去网上找一下https://hexo.io/themes/http://www.jianshu.com/p/bcdbe7347c8d 对于博客需要图片什么的不推荐直接上传，可以在七牛云里面申请空间，七牛云存储也提供了免费CDN配额：存储空间 10GB，每月下载流量 10GB，每月 PUT/DELETE 10万次请求，每月 GET 100万次请求。月流量在10GB以下的博客基本上可以一直免费使用七牛云存储CDN服务了","categories":[{"name":"技术","slug":"技术","permalink":"https://xdong.me/categories/技术/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://xdong.me/tags/hexo/"},{"name":"github","slug":"github","permalink":"https://xdong.me/tags/github/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xdong.me/categories/技术/"}]},{"title":"tomcat 打开 startup.bat闪退","slug":"tomcat-打开-startup-bat闪退","date":"2017-07-25T04:20:06.000Z","updated":"2019-08-25T11:23:58.225Z","comments":true,"path":"2017/07/25/tomcat-打开-startup-bat闪退/","link":"","permalink":"https://xdong.me/2017/07/25/tomcat-打开-startup-bat闪退/","excerpt":"","text":"原因tomcat安装好之后再bin目录下有startup.bat,双击之后闪退，这一般是由于环境变量设置问题 可以在cmd里查看相关信息，win+r 输入cmd，之后cd到tomcat安装目录的bin目录下，然后输入startup.bat如果提示缺少JAVA_HOME 或者缺少JRE_HOME，那么就是环境变量的问题，一般也就是这个错误 解决方案可以通过设置JAVA_HOME 和 JRE_HOME来解决，需要JDK，这个可以参考教程安装，安装好之后，计算机-&gt;属性-&gt;环境变量，win10是计算机-&gt;属性-&gt;高级系统设置-&gt;环境变量选择新建系统变量，变量名为JAVA_HOME，变量值为：JDK安装目录\\jdk，然后新建JRE_HOME变量，变量值为jdk安装目录下jdk\\jre之后将这两个变量放到path系统变量中，在path变量值的后面直接追加 ;%JAVA_HOME%;%JRE_HOME%这个必须是这个格式，并且;不可少，如图保存之后就可以启动tomcat 如有错误，欢迎指正","categories":[{"name":"技术","slug":"技术","permalink":"https://xdong.me/categories/技术/"}],"tags":[{"name":"tomcat","slug":"tomcat","permalink":"https://xdong.me/tags/tomcat/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xdong.me/categories/技术/"}]},{"title":"ACM经历","slug":"ACM经历","date":"2017-07-23T16:00:00.000Z","updated":"2019-08-25T11:20:25.610Z","comments":true,"path":"2017/07/24/ACM经历/","link":"","permalink":"https://xdong.me/2017/07/24/ACM经历/","excerpt":"","text":"2年的经历，教给我很多东西，会遗忘吗？ 当然不会 个人经历 在上大学之前也接触过计算机，但是编程基本什么都不懂，在高二拿软件做过一个小的网页，好多文字图片拼凑起来，没什么技术性可言，但还是喜欢计算机，这可能就是兴趣吧。 上了大学，第一次接触C语言，还有这么神奇的东西，几天用着一个printf激动的要死，也渐渐明白代码的强大，计算机的强大。C开课前我看了前三章的内容，当时由于教材不太好，第二章就出现了位运算，难得要死，一个一个查一个一个算，问助班，看百度，搞懂那会真的贼高兴。后来开始正式上课，我也认识了陈大师（C语言老师，ACM集训队教练），第一次正式了解了ACM，听着高大上，又说每年从全校录取30个人左右（虽然大部分是计算机学院的），觉得很厉害，当时就定下进ACM这个目标。 老师在OJ上面安排了好多题，一放出来我就去做，有时是凌晨那会，上床我也拿手机做（大一上半学期没带电脑），总的来说有空就做，我也保持了大部分专题的第一，虽然只是专业排名，不过也觉得很有成就感，同样认识了好多大佬，都是其他专业排名靠前的。 进集训队要通过12月中旬的新生选拔赛，选取排名靠前的，很幸运，我排名18，虽然觉得没发挥好，但是进了ACM候选队员。在下学期有个校赛，全校的都可以参加，也有前几届的，这次比赛打的比新生赛好多了，拿了一等奖，名次不记得了，值得一提的是新生赛第一和校赛第二是我们15级的一个女生，完虐我们这些男的，还是我们班的，后来成为了我的队友。慢慢的经过多场比赛的选拔，积分排名淘汰了一部分人，我也成为了正式队员，当时我的积分排名竟然还是第一，顿时觉得自己也很厉害（这应该是错觉） 进了集训队就很辛苦了，周末要抽出一下午比赛，有几小时上课，但是对自己能力有很大提升。在5月份左右要打市赛，3个人组一队，很可惜没和王春大佬组队，春神可以说15级最强了，难受的是市赛发挥失常，多亏陈大神（校赛完虐我们的女生）做了一题，不至于爆零。暑假要集训，就10多天假期，慢慢发现我其实天赋并不好，就是逻辑强一些，也就是说实力不强。暑假期间由于陈大神的退队我们小队变得很差，省赛才4个队的名额，14级占了一半，我们小队肯定参加不了，唉。。 接下来一年断断续续训练和比赛，学了点其他东西，有点荒废，还去做了新生上机的指导，一年实力也没多大提升，还好大二市赛拿了银奖，同时还有全国邀请赛铜奖，算是我拿到最好的奖了。 暑假集训前由于一些原因退出了集训队，和陈大师交流了一下，没想到老师对我希望还很高，可惜我还是退出了。 感受心得 这两年参加ACM收获很大，特别是算法逻辑都有很大提升，在各大oj也刷了一些题，参加了几次cf,bc,atcoder,参加过一些学校的比赛，一些网络赛，虽然实力不够强，但经验增加很多，同样认识了很多大佬，其他学校的也认识了一些，他们是真的强。不过由于我的智商还是不够，搞应用吧，这个也不需要也别高的算法能力，到现在搭建了自己的博客，也算是在其他方面踏出了一步。 我提到的大佬很少，主要是不知道提了会不会挨骂，哈哈哈","categories":[{"name":"生活","slug":"生活","permalink":"https://xdong.me/categories/生活/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://xdong.me/tags/ACM/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://xdong.me/categories/生活/"}]}]}