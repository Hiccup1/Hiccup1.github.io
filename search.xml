<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>WAF 实现透明部署-原理及操作步骤</title>
      <link href="/2023/04/26/WAF%20%E5%AE%9E%E7%8E%B0%E9%80%8F%E6%98%8E%E9%83%A8%E7%BD%B2-%E5%8E%9F%E7%90%86%E5%8F%8A%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4/"/>
      <url>/2023/04/26/WAF%20%E5%AE%9E%E7%8E%B0%E9%80%8F%E6%98%8E%E9%83%A8%E7%BD%B2-%E5%8E%9F%E7%90%86%E5%8F%8A%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>此文章主要参考了一篇文章和FortiWeb Guide文档，原理也是和chatgpt沟通得到的，具体链接放到了最后.</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>此文章会涉及到网桥、iptables等配置，使用时可能会影响正常的网络通信，不当的使用可能会导致网络故障或安全问题。因此，<strong>此文章需要的服务器网络全都是独立的，不要把他们接入公司或者你正在使用的网络中，避免引发网络问题</strong>。</li><li>服务器最好先进行时间同步，确保这些服务器全都是一样的时间</li></ol><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>三台Centos7服务器， 分别做客户端（网关）、WAF服务器（透明桥）、WEB服务器。</li><li>WAF服务器要有多个网口，其中有2个接口要做桥接，还有1个管理口。</li><li>2条网线，以及其他线材和外设保证服务器能正常运行和操作。</li><li>显示器， 需要直连服务器。或者用PC可以远程操作这些服务器，但这个要防止网络异常，最好是直连服务器操作。</li></ul><h2 id="实现客户端和WEB服务器正常通信"><a href="#实现客户端和WEB服务器正常通信" class="headerlink" title="实现客户端和WEB服务器正常通信"></a>实现客户端和WEB服务器正常通信</h2><p>首先在没有WAF透传的情况下要保证客户端和WEB服务器通信是正常的。</p><ol><li><p>客户端服务器最好有界面，可以用firefox浏览器。配置客户端其中一个网口的IP地址和子网掩码, 比如</p><blockquote><p>IP: 172.16.0.1   子网掩码: 255.255.255.0， 网关不要填写</p></blockquote></li><li><p>WEB服务器安装WEB服务，可以用nginx搭建一个HTTP服务，此处不细说，后续会假定HTTP服务为80端口提供。 配置WEB服务器其中一个网口的IP地址和子网掩码， 比如：</p><blockquote><p>IP: 172.16.0.3   子网掩码: 255.255.255.0， 网关: 172.16.0.1</p></blockquote></li><li><p>用一根网线直连这2台服务器的对应网口，然后可以用ping命令测试是否联通，也可以直接在客户端通过浏览器访问 172.16.0.3:80， 看看响应是否正常。</p></li></ol><h2 id="WAF服务器配置桥接"><a href="#WAF服务器配置桥接" class="headerlink" title="WAF服务器配置桥接"></a>WAF服务器配置桥接</h2><ol><li>比如WAF服务器有6个网口，服务器中显示的网卡分别是enp2s0、enp3s0….enp6s0、enp7s0。<br>首先确定管理口，提供给PC或者远程连接操作，目前也可以用显示器直连服务器操作，比如用enp2s0做管理口。</li><li>确定桥接的2个接口，比如用enp6s0和enp7s0</li><li>关闭centos 7自带防火墙<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br><span class="line">systemctl disable firewalld.service</span><br></pre></td></tr></tbody></table></figure></li><li>安装ifconfig 和网桥工具包<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install net-tools.x86_64</span><br><span class="line">yum -y install bridge-utils</span><br></pre></td></tr></tbody></table></figure></li><li>关闭和禁用 NetworkManager 服务，启用 network 服务<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chkconfig NetworkManager off</span><br><span class="line">chkconfig network on</span><br><span class="line">service NetworkManager stop</span><br><span class="line">service network start</span><br></pre></td></tr></tbody></table></figure></li><li>添加网桥<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/sbin/modprobe bridge</span><br><span class="line">/usr/sbin/brctl addbr br0（设置网桥名为br0）</span><br><span class="line">/sbin/ifup enp6s0 （要加入网桥的网卡，通过ifconfig查看, 启动此网卡）</span><br><span class="line">/sbin/ifup enp7s0 （要加入网桥的网卡）</span><br></pre></td></tr></tbody></table></figure></li><li>将 enp6s0 和 enp7s0 网络接口添加到名为 br0 的网桥设备中<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/sbin/brctl addif br0 enp6s0</span><br><span class="line">/usr/sbin/brctl addif br0 enp7s0</span><br></pre></td></tr></tbody></table></figure></li><li>设置网桥IP （例：172.16.0.2 设置一个在内网网段的IP）<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig br0 172.16.0.2 netmask 255.255.255.0</span><br></pre></td></tr></tbody></table></figure></li><li>开启网桥<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sbin/ip link set br0 up</span><br></pre></td></tr></tbody></table></figure></li><li>查看网桥<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo brctl show</span><br></pre></td></tr></tbody></table></figure>如果以上步骤都正常，则会显示如下内容<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">br0             8000.4062311c9132       no              enp6s0</span><br><span class="line">                                                            enp7s0</span><br></pre></td></tr></tbody></table></figure></li><li>如果上述步骤网桥IP之类设置错误，可以删掉重新设置。<strong>如果正常不要执行此步骤内容</strong>。<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 关闭网桥</span><br><span class="line">ifconfig br0 down</span><br><span class="line"># 删除br0</span><br><span class="line">sudo brctl delbr br0</span><br><span class="line"># 然后重新添加网桥br0，然后将enp6s0、enp7s0加入网桥，设置br0的Ip和掩码，再启动</span><br></pre></td></tr></tbody></table></figure></li><li>这时候就用2条网线，1条连接客户端网口和enp6s0网络接口，另1条连接enp7s0和WEB服务器网口。<br>在客户端使用浏览器访问 172.16.0.3:80 ，如果正常则会显示WEB服务器HTTP的响应界面。 此时已经桥接成功。</li></ol><h2 id="将流量导向WAF服务"><a href="#将流量导向WAF服务" class="headerlink" title="将流量导向WAF服务"></a>将流量导向WAF服务</h2><p>现在2个接口桥接可以使网络通信正常，而且没有更改客户端和WEB服务器配置，把刚刚的网线拿掉，连接客户端和WEB服务器还可以正常通信。<br>但是我们目的还是要经过WAF处理请求数据，所以还需要将请求导入WAF处理，WAF是7层的，所以需要利用iptables做NAT转换，让WAF插入中间做透明代理。</p><ol><li><p>安装iptables 并开启</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum -y install iptables</span><br><span class="line">yum -y install iptables-services</span><br><span class="line">service iptables start</span><br></pre></td></tr></tbody></table></figure></li><li><p>在/etc/sysctl.conf下添加内容, 也就是编辑此文件，在最后添加相关配置</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 启用 IPv6 数据包的防火墙过滤功能。当网桥设备转发 IPv6 数据包时，可以使用防火墙规则对数据包进行过滤和控制</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line"># 启用 IPv4 数据包的防火墙过滤功能。当网桥设备转发 IPv4 数据包时，可以使用防火墙规则对数据包进行过滤和控制。</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line"># 启用 ARP 数据包的防火墙过滤功能。当网桥设备转发 ARP 数据包时，可以使用防火墙规则对数据包进行过滤和控制。</span><br><span class="line">net.bridge.bridge-nf-call-arptables = 1</span><br><span class="line"># 启用 Linux 操作系统的 IP 转发功能。当网桥设备转发数据包时，可以使用 IP 转发功能将数据包转发到其他网络。</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line"># 启用 Linux 操作系统的端口绑定功能。当网桥设备绑定端口时，可以使用端口绑定功能将端口绑定到非本地 IP 地址。</span><br><span class="line">net.ipv4.ip_nonlocal_bind = 1</span><br><span class="line"># 禁用 Linux 操作系统的反向路径过滤功能。反向路径过滤是一种网络安全功能，用于检查数据包的源地址是否合法。禁用反向路径过滤可以提高网桥设备的网络性能和灵活性。</span><br><span class="line">net.ipv4.conf.default.rp_filter = 0</span><br><span class="line"># 禁用 Linux 操作系统的反向路径过滤功能。同上。</span><br><span class="line">net.ipv4.conf.all.rp_filter = 0</span><br><span class="line"># 禁用网桥设备 br0 的反向路径过滤功能。同上。</span><br><span class="line">net.ipv4.conf.br0.rp_filter = 0</span><br></pre></td></tr></tbody></table></figure></li><li><p>执行命令使生效</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></tbody></table></figure></li><li><p>如果报错：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sysctl: cannot stat /proc/sys/net/bridge/bridge-nf-call-ip6tables: 没有那个文件或目录</span><br><span class="line">sysctl: cannot stat /proc/sys/net/bridge/bridge-nf-call-iptables: 没有那个文件或目录</span><br><span class="line">sysctl: cannot stat /proc/sys/net/bridge/bridge-nf-call-arptables: 没有那个文件或目录</span><br><span class="line"># 执行</span><br><span class="line">modprobe br_netfilter</span><br><span class="line"># 再次执行</span><br><span class="line">sysctl -p</span><br></pre></td></tr></tbody></table></figure></li><li><p>添加路由, 这个步骤是上述文章提到，我还没明白这个作用</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 添加一个 IP 路由规则，将标记为 1 的数据包转发到 ID 为 100 的路由表中。这个命令可以实现基于标记的流量控制，例如将特定的数据包流量转发到指定的网络接口或网关中。</span><br><span class="line">/sbin/ip -f inet rule add fwmark 1 lookup 100</span><br><span class="line"># 添加一个本地路由规则，将本地流量转发到 ID 为 100 的路由表中。这个命令可以实现本地流量的负载均衡，例如将本地流量分散到多个网络接口或网关中，从而提高网络性能和可靠性。</span><br><span class="line">/sbin/ip -f inet route add local default dev lo table 100</span><br></pre></td></tr></tbody></table></figure></li><li><p>首先检查是否有其他iptables规则，如果有，则需要先删除</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 检查iptables NAT规则</span><br><span class="line">sudo iptables -t nat -L -n --line-numbers</span><br><span class="line"># 这个命令将列出当前iptables的nat表中的PREROUTING和POSTROUTING规则，以及它们的行号。</span><br><span class="line"># 删除PREROUTING规则</span><br><span class="line">sudo iptables -t nat -D PREROUTING [行号]</span><br><span class="line"># 删除POSTROUTING规则</span><br><span class="line">sudo iptables -t nat -D POSTROUTING [行号]</span><br></pre></td></tr></tbody></table></figure></li><li><p>添加DNAT规则, 其中前面的172.16.0.3和80端口是WEB服务器的IP和HTTP服务端口，后面的172.16.0.2:8080，则是WAF服务器网桥IP和WAF服务的端口，8080是WAF提供的代理HTTP服务端口</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -d 172.16.0.3 -p tcp --dport 80 -j DNAT --to-destination 172.16.0.2:8080</span><br></pre></td></tr></tbody></table></figure></li><li><p>保存iptables规则，重启服务</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service iptables save</span><br><span class="line">service iptables restart</span><br></pre></td></tr></tbody></table></figure></li><li><p>以上，系统透明模式需要的设置已完成，WAF可以自行安装，参考上述文章的shareWAF或者自己准备其他WAF服务，也可以简单装一个nginx，打开access.log，看是否有请求转到nginx。如果一切正常，此时在客户端请求172.16.0.3:80, 是通过了WAF转发的，WAF可以看到请求，而且客户端和WEB端都无需修改配置，还正常响应</p></li></ol><h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><p>现在功能是正常了，但是还可以进一步研究网络是如何通信的，那就需要抓包看数据了，分别使用如下命令在客户端、WAF、和WEB服务器抓包, 网卡替换成对应网卡</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -n -X -i enp2s0 -w client.pcap</span><br><span class="line">tcpdump -n -X -i br0 -w waf.pcap</span><br><span class="line">tcpdump -n -X -i enp2s0 -w server.pcap</span><br></pre></td></tr></tbody></table></figure><p>然后用客户端浏览器发送请求，等响应正常后可以ctrl+c停止抓包，将抓包文件导出到windows中，利用wireshark研究数据</p><h3 id="客户端数据"><a href="#客户端数据" class="headerlink" title="客户端数据"></a>客户端数据</h3><ol><li>红圈中的这条数据就是ARP协议数据，ARP是通过IP地址找MAC地址的，这条数据是客户端(172.16.0.1)发送一个 ARP Announcement 消息到局域网中，以通知其他主机更新自己的 ARP 缓存表， 客户端发送给ff:ff:ff:ff:ff:ff 是广播地址，用于将数据包发送到网络中的所有主机。参数就是自己的mac地址(40:8d:5c:d7:49:ed)<br><img src="https://turing.run/wp-content/uploads/2023/04/2023042609312333.png" alt="桥接-客户端-arp"></li><li>这条数据也是arp协议数据，是客户端(172.16.0.1)询问WEB服务器(172.16.0.3)的mac地址，然后收到了回复。可以看到客户端也是发送到广播地址，然后收到了WEB服务器的mac地址（40:8d:5c:f2:aa:6f）<br><img src="https://turing.run/wp-content/uploads/2023/04/2023042609501886.png"></li><li>客户端和WEB服务器的http通信，直接看图, 展示了3次握手和http通信数据，HTTP 状态码 304 Not Modified 表示客户端发送的请求的资源没有发生修改，因为我前面请求了几次，所以服务器没有返回资源的内容，而是返回一个空的响应体，告诉客户端可以使用缓存中的资源。<br><img src="https://turing.run/wp-content/uploads/2023/04/2023042609573686.png"></li></ol><blockquote><p>从上面图可以看到客户端(172.16.0.1)一直和WEB服务器（172.16.0.3）通信，并没有感受到WAF的存在。</p></blockquote><h3 id="WEB服务器数据"><a href="#WEB服务器数据" class="headerlink" title="WEB服务器数据"></a>WEB服务器数据</h3><p>先看WEB服务器数据，因为WAF的稍微有点绕，可以先理解WEB服务器通信，如下图所示<br><img src="https://turing.run/wp-content/uploads/2023/04/2023042610043388.png"></p><ol><li>ARP相关的和客户端一样，都是广播自己的mac，然后收到了客户端(172.16.0.1)询问WEB服务器(172.16.0.3)的mac地址，然后返回自己的mac</li><li>可以看到3次握手，和http请求响应数据</li><li>多了个四次挥手</li></ol><blockquote><p>这个就看出问题了，WEB服务器不是和客户端直接通信的，因为看他的ip地址是 172.16.0.2:31515和172.16.0.3:80 通信，这个是WAF和WEB服务器通信的。在客户端我们看到的截图是172.16.0.1:50635和172.16.0.3:80通信的。<br>还有就是多了四次挥手，客户端并没有看到。<br>这2个不同点就说明中间是有WAF劫持了流量，而且WAF后续和WEB服务器进行了通信</p></blockquote><h3 id="WAF数据"><a href="#WAF数据" class="headerlink" title="WAF数据"></a>WAF数据</h3><p><img src="https://turing.run/wp-content/uploads/2023/04/2023042610171029.png"></p><ol><li>可以看到ARP协议数据，不再多说，和上面一样</li><li>三次握手有2部分，这个就特殊了，先解释为什么会有2个TCP三次握手，因为iptables做了DNAT也就是改了数据包的目标IP地址，上面那条iptables命令检测到发往WEB服务器172.16.0.3:80 的数据，就会将目标IP和端口改为172.16.0.2:8080。这也就是可以看到第一次握手是客户端发给WAF的，因为被iptables改了，这就相当于客户端和WAF做了TCP连接。又因为WAF做的桥接，对客户端是透明的，所以syn+ack显示的是172.16.0.3和172.16.0.1。</li><li>后面是客户端发的http请求，然后就是WAF和WEB服务器做的TCP握手（第二部分三次握手），这也就是WEB服务器抓包看到的三次握手。</li><li>握手成功后WAF转发HTTP请求到WEB服务器，然后收到WEB服务器的响应，之后就断开和WEB服务器的TCP连接，最后把响应转发给客户端</li></ol><blockquote><p>对客户端来说，他是不知道有WAF存在的，抓包可以看到与客户端通信的都是WEB服务器的IP。对WEB服务器来说，与他通信的是WAF的网桥IP，所以对WEB服务器没有做到真正的透明。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于中间的设备加了iptables转发的步骤，才能让WAF可以处理经过的流量，WAF会和WEB服务器做TCP连接，这样也不算完全的透明，如果没有iptables做转发，那么对客户端和WEB服务器都只会显示对方的IP，无法感知到WAF存在。<br>但是这个也是透明部署，因为无需修改客户端和WEB服务器配置。当然实际部署情况应该是WAF前面有一个网关或者网络防火墙，然后另一端是WEB服务器，同样不需要修改两端的配置，只需要修改WAF配置即可。如果用bypass网卡，在WAF设备出故障时也可以实现透明传输，更稳定。</p><h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><ul><li>chatgpt</li><li><a href="https://blog.csdn.net/weixin_39615402/article/details/110892668">npm 设置代理_高端操作：DIY一台硬件WAF！透明代理</a></li><li><a href="https://fortinetweb.s3.amazonaws.com/docs.fortinet.com/v2/attachments/ffa8ad27-f62d-11e9-8977-00505692583a/FortiWeb_6.2.1_Administration_Guide.pdf">FortiWeb Guide WAF文档</a></li><li>FortiWeb Guide WAF透明部署示意图：<br><img src="https://s2.loli.net/2023/04/19/KlTWRrFwhEZfMgv.png" alt="图"></li></ul>]]></content>
      
      
      <categories>
          
          <category> WAF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WAF </tag>
            
            <tag> Centos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式判断质数-有点意思</title>
      <link href="/2023/03/31/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%A4%E6%96%AD%E8%B4%A8%E6%95%B0-%E6%9C%89%E7%82%B9%E6%84%8F%E6%80%9D/"/>
      <url>/2023/03/31/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%A4%E6%96%AD%E8%B4%A8%E6%95%B0-%E6%9C%89%E7%82%B9%E6%84%8F%E6%80%9D/</url>
      
        <content type="html"><![CDATA[<h3 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h3><p>最近偶然发现一篇文章说正则可以判断一个数是不是素数，当时就懵了，一看正则：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^1?$|^(11+?)\1+$</span><br></pre></td></tr></tbody></table></figure><p>第一眼没看懂，这不都是判断1么，感觉和数字没关系，细看文章内容，他又说道用Ruby写了个代码</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def is_prime(n)</span><br><span class="line">  ("1" * n) !~ /^1?$|^(11+?)\1+$/</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure><p>我让ChatGPT改造了一下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def is_prime(n)</span><br><span class="line">  ("1" * n) !~ /^1?$|^(11+?)\1+$/</span><br><span class="line">end</span><br><span class="line">print "请输入一个数字："</span><br><span class="line">n = gets.chomp.to_i</span><br><span class="line">puts "#{n} 是素数吗？#{is_prime(n)}"</span><br></pre></td></tr></tbody></table></figure><p>这段代码作用是接收一个数字输入n，然后把n转成n个1组成的字符串，再用这段字符串去匹配正则，然后输出是不是素数。</p><p>由于我不会Ruby，所以找了个在线运行的网站试了一下<a href="https://www.onlinegdb.com/online_c++_compiler">Online Compiler - online editor</a>，这个网站可以支持很多种语言在线编译运行。右上角选Ruby就可以体验。经过测试，确实返回的结果都是对的，这接下来就得研究一下这个正则了，为什么可以判断素数？</p><h3 id="正则解析"><a href="#正则解析" class="headerlink" title="正则解析"></a>正则解析</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^1?$|^(11+?)\1+$</span><br></pre></td></tr></tbody></table></figure><p>这个正则可以分成两部分，因为中间有个 |  ，就是或的意思，前半段正则和后半段只要有一段匹配到就可以。</p><ol><li>^1?$ 这段比较简单，^匹配字符串开始，$匹配字符串结束，中间1就表示匹配一个1字符，?表示匹配0次或1次, 也就是说这段作用是匹配0个或1个’1’字符，代码里就是判断n==0或者n==1的情况</li><li>^(11+?)\1+$  这段就有意思了，先看(11+?)，这是一个分组(子表达式)，11就是匹配11，+表示匹配1次或多次，?是非贪婪模式，所以这个分组将尽可能短地匹配字符串，作用是匹配以2个或以上的 1 开头的字符串，并将其捕获到分组 1 中。比如可以匹配11、111、1111、11111等等。<br>\1+  这个就是再次匹配分组1，然后+表示1次或多次。作用就是匹配分组 1 中的内容重复1次或多次。<br>那么第二段结合起来就可以匹配到<strong>11</strong>11、<strong>111</strong>111111、<strong>11</strong>1111，加粗的就是分组1的内容，后面就是分组1重复了多次，不知道能不能理解这个意思。</li></ol><p>下面结合数字来看一下<br><img src="https://turing.run/wp-content/uploads/2023/03/2023033103165689.png" alt="正则匹配" title="正则匹配"></p><ul><li>比如3 转换字符串 111，这个就匹配不到，因为没办法找到2个或以上的1 （分组1要求要2个或以上的1），然后有重复多次的</li><li>比如n==9，111111111， 分组1就是3个111，重复3次，可以匹配到</li><li>n==25，分组1就是11111，重复5次，可以匹配到</li><li>n==49，分组1就是1111111，重复7次，可以匹配到</li><li>n==17，匹配不到，因为没办法找到2个或以上的1，然后重复多次</li><li>n==6，分组1是11 （因为懒惰模式，尽可能匹配短的字符串），重复3次</li></ul><p>现在应该看出来了，这个正则匹配的就是2、3、5、7、11等等这些数的倍数，尝试找到n的因数，素数是没有除了1和他本身之外的因数，所以这个正则是对的。</p><p><strong>有点意思</strong></p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>我没有自己测试，而是直接问了ChatGPT</p><blockquote><p> <code>("1" * n) !~ /^1?$|^(11+?)\1+$/</code> 这段代码性能怎么样？</p></blockquote><blockquote><p>这段代码的性能与输入数字的大小有关，并且在某些情况下可能比传统的质数检测算法要快。<br>首先，该代码使用了字符串重复操作 <code>"1" * n</code> 来构造一个长度为 n 的字符串，然后将其传递给正则表达式进行匹配。因此，如果输入的数字很大，那么字符串重复操作可能会耗费较多的时间和内存。另外，如果输入的数字是质数，那么该正则表达式需要遍历整个字符串才能确定它是质数，这可能会导致性能瓶颈。<br>然而，在某些情况下，该代码的性能可能会优于传统的质数检测算法。例如，对于较小的数字（比如小于 10^6），该代码通常比试除法或米勒-拉宾素性检验等传统算法更快。这是因为正则表达式引擎通常在处理短字符串时具有很高的效率，并且可以充分利用现代计算机的并行处理能力。<br>总之，这段代码的性能与输入数字的大小有关，如果输入的数字很大，则可能会出现性能问题。但是，对于较小的数字，该代码可能比传统的质数检测算法更快。如果需要在实际应用中使用该代码，请根据具体情况进行测试和优化。</p></blockquote><p>他的回答是： 对于较小的数字（比如小于 10^6），该代码通常比试除法或米勒-拉宾素性检验等传统算法更快。<br>具体性能怎样，还得仔细测试，毕竟ChatGPT也有可能是编的。而且这个n越大，占用内存也越大，只能当做一个小技巧，实际运用还需要注意。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>发散一下思维，这个正则是找某个数的倍数，那么奇数偶数也可以这样判断，那就是找2的倍数。<br>这就是正则有意思的地方，以前一直以为正则就是匹配特定字符串啥的，没想到这种数学思维也可以结合起来，不得不说：有点东西。</p><h3 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h3><p><a href="https://www.noulakaz.net/2007/03/18/a-regular-expression-to-check-for-prime-numbers/">检测质数的正则原文章</a><br><a href="https://deerchao.cn/tutorials/regex/regex.htm">正则表达式30分钟入门教程</a><br><a href="https://deerchao.cn/tools/wegester/">JavaScript 在线正则测试器</a><br><a href="https://www.onlinegdb.com/online_c++_compiler">在线运行代码网站</a></p>]]></content>
      
      
      <categories>
          
          <category> 正则表达式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP压力测试教程</title>
      <link href="/2023/02/05/HTTP%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E6%95%99%E7%A8%8B/"/>
      <url>/2023/02/05/HTTP%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>这篇文章主要介绍HTTP压力测试的工具和一些特殊技巧，不会详细写使用方法，而是重点关注wrk这个压测工具，用它来测试多个性能指标。至于服务器端的调优可以参考前面几篇高并发配置文章。</p><h3 id="压测工具介绍"><a href="#压测工具介绍" class="headerlink" title="压测工具介绍"></a>压测工具介绍</h3><ol><li>Apache JMeter：Apache JMeter 是一个开源的 Java 压力测试工具，可以通过图形化界面创建测试计划，并模拟用户请求、并发量等场景进行测试。</li><li>ab：ab（Apache Bench）是一个简单的命令行式压力测试工具，可以模拟多个并发用户对目标 URL 进行请求，并提供基本的统计信息和报告功能。</li><li>vegeta: Vegeta是一个通用的HTTP负载测试工具，它可以用恒定请求速率进行测试。它既可以用作命令行实用程序，也可以用作库。</li><li>wrk: wrk 是一款针对 Http 协议的基准测试工具，它能够在单机多核 CPU 的条件下，使用系统自带的高性能 I/O 机制，如 epoll，kqueue 等，通过多线程和事件模式，对目标机器产生大量的负载。</li></ol><p>还有很多压测工具，但是我只想详细说一下wrk和vegeta。主要推荐使用wrk来测试</p><p><strong>注： 此文章这些工具都是使用Centos7安装部署的</strong></p><h3 id="vegeta"><a href="#vegeta" class="headerlink" title="vegeta"></a>vegeta</h3><p>github地址： <a href="https://github.com/tsenart/vegeta">https://github.com/tsenart/vegeta</a></p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>vegeta安装非常简单，因为是go语言写的，可以直接下载官方的预编译版本后开箱即用。简单安装使用可以参考这篇文章<a href="https://www.cnblogs.com/zhangb8042/p/10237161.html%E3%80%82">https://www.cnblogs.com/zhangb8042/p/10237161.html。</a> 此处不详细说</p><h4 id="优势-amp-缺点"><a href="#优势-amp-缺点" class="headerlink" title="优势 &amp; 缺点"></a>优势 &amp; 缺点</h4><p>优势如下：</p><ul><li>vegeta性能很好。单个客户端就能提供很大吞吐量。</li><li>支持多台客户端同时压测。因为单台客户端1个IP就会受到连接数端口限制，最多65535个端口。如果想测试最大并发连接数就需要多个客户端来压测。在github中提到过用pdsh可以实现，具体使用方法可以谷歌/百度一下。</li><li>使用简单。命令行重要的参数不多，很容易掌握，支持多种请求方式。</li><li>支持固定速率压测。</li></ul><p>缺点我个人觉得有2个：</p><ul><li>压测文件可能会很大。如果压测吞吐量很大，而且压测时间很长，vegeta就会生成很大的压测文件，在生成报告时会占用很大时间。特别是多台压测时，几万QPS压测10分钟可能就有几个G的文件大小。</li><li>没办法固定客户端的连接数。就是不支持客户端建立固定数量的TCP连接，这样不好测试最大并发连接数。</li></ul><h3 id="wrk"><a href="#wrk" class="headerlink" title="wrk"></a>wrk</h3><p>wrk github: <a href="https://github.com/wg/wrk">https://github.com/wg/wrk</a><br>我更推荐使用wrk2，这个在wrk的基础上做了一些增强，可以支持固定吞吐量发压<br>wrk2 github: <a href="https://github.com/giltene/wrk2">https://github.com/giltene/wrk2</a><br>多客户端wrk github: <a href="https://github.com/anio/wrk-utils">https://github.com/anio/wrk-utils</a></p><p>第三个地址是利用多客户端压测使用的（集群）,可以配置多个发压客户端，通过一条命令直接启动，测试完结果会显示在控制端。</p><h4 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h4><p>wrk2的使用可以参考github地址，也可以搜索一些使用文章参考。后续的都是使用wrk2进行测试的<br>举个例子：</p><blockquote><p>wrk -t2 -c100 -d30s -R2000 <a href="http://127.0.0.1:8080/index.html">http://127.0.0.1:8080/index.html</a></p></blockquote><p>这条命令意思是使用2个线程(-t2)，打开100个TCP连接(-c100)，运行30s(-d30s)，压测速度为2000/s (-R2000)，请求接口为<a href="http://127.0.0.1:8080/index.html">http://127.0.0.1:8080/index.html</a></p><p>在wrk-utils工具中，会有个stats.lua文件，如果会lua语言的话可以在里面修改一些请求代码，比如更改请求方式、请求类型、请求体、请求头等等，wrk可以支持lua语言。</p><h4 id="wkr2-wrk-utils-安装-使用"><a href="#wkr2-wrk-utils-安装-使用" class="headerlink" title="wkr2+wrk-utils 安装+使用"></a>wkr2+wrk-utils 安装+使用</h4><p>当使用wrk-utils时，他自带的wrk不是wrk2，所以需要自己下载编译wrk2为可执行文件。<br>部署wrk2可以参考<a href="https://www.bilibili.com/read/cv9547855/">https://www.bilibili.com/read/cv9547855/</a><br>这篇文章是部署wrk的，但我们要使用wrk2，所以要替换下载wrk2的github文件。</p><p>然后部署wrk-utils很简单，只需要git clone到指定目录就可以，然后将生成的wrk2的可执行文件替换掉原来的wrk文件。多台服务器还需要安装sshpass，要配置免密登录。具体安装部署可以参考<a href="https://github.com/anio/wrk-utils">https://github.com/anio/wrk-utils</a><br>比较重要的步骤如下：</p><ol><li><p>先确定好发压客户端，并且配置免密登录</p></li><li><p>在wrk-utils目录下新建一个servers.txt文件，写入客户端ip，一个ip一行。或者按教程填写此文件</p></li><li><p>执行命令如下命令启动，注意不要有/之类，直接复制即可</p><blockquote><p>. activate.sh</p></blockquote></li><li><p>执行如下命令初始化</p><blockquote><p>init-servers</p></blockquote></li><li><p>available-node-count 命令可以显示可用的客户端节点数量，kill-all 命令可以停止所有的客户端进程</p></li><li><p>执行压测命令，等待执行完成就会显示测试结果</p></li></ol><p>wrk-utils的命令一般如下所示：</p><blockquote><p>exec-wrk 10 -t10 -c300 -d600s -R2000 -T60s –latency -s stats.lua ‘<a href="https://example.com/path/?id=1'">https://example.com/path/?id=1'</a></p></blockquote><p>这些参数都是每台客户端独立执行的</p><ul><li>10 表示下一台机器执行wrk命令的延迟，也就是下一台机器延迟10s执行。因为如果瞬间几十台客户端发压，这个TCP新建连接速度会很大，如果服务器没做配置就会有大量失败。如果是测试吞吐量就应该避免瞬间流量过大，而是要慢慢升高压力。</li><li>-t10 表示客户端10个线程，这个是每台客户端都是10个线程，不是总共的</li><li>-c300 表示客户端建立300个TCP连接，这个也是每台客户端单独的</li><li>-d600s 表示压测600s，也就是10分钟</li><li>-R2000 表示压测速度为每秒2000次请求，wrk2提供</li><li>-T60s 表示超时时间60s</li><li>–latency 表示展现详细的测试结果，wrk2提供</li><li>-s stats.lua 加载lua脚本文件</li><li>‘<a href="https://example.com/path/?id=1'">https://example.com/path/?id=1'</a>  请求的http接口</li></ul><h4 id="分析压测结果"><a href="#分析压测结果" class="headerlink" title="分析压测结果"></a>分析压测结果</h4><p>测试完成可以看到结果输出，但是不会汇总，他是直接输出每一台客户端的结果，如下</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Running 10s test @ http://127.0.0.1:8080</span><br><span class="line">  10 threads and 100 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     4.75ms    4.07ms  26.19ms   83.06%</span><br><span class="line">    Req/Sec       -nan      -nan   0.00      0.00%</span><br><span class="line">  Latency Distribution (HdrHistogram - Recorded Latency)</span><br><span class="line"> 50.000%    2.86ms</span><br><span class="line"> 75.000%    7.21ms</span><br><span class="line"> 90.000%   10.47ms</span><br><span class="line"> 99.000%   16.48ms</span><br><span class="line"> 99.900%   20.96ms</span><br><span class="line"> 99.990%   26.21ms</span><br><span class="line"> 99.999%   26.21ms</span><br><span class="line">100.000%   26.21ms</span><br></pre></td></tr></tbody></table></figure><p>其中可以关注平均延迟，50%、90%、99%的请求延迟<br>之后会显示更精细的延迟数据，此处不再展示。最后会显示吞吐量等数据，如下所示</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 1810 requests in 10.00s, 9.40MB read</span><br><span class="line">Requests/sec:    180.95</span><br><span class="line">Transfer/sec:      0.94MB</span><br><span class="line">192.168.10.1 Done!</span><br></pre></td></tr></tbody></table></figure><p>这就表示总共有1810个请求，压测10s，请求180.95次每秒，吞吐量 0.94MB每秒<br>此处的吞吐量是服务器实际的吞吐量，比如你压测1000次每秒，可能服务器只能做到200次每秒。</p><p>如果有异常，还可能会显示TCP socket的异常，如下所示</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Socket errors: connect 1016, read 1968, write 33, timeout 1160</span><br></pre></td></tr></tbody></table></figure><p>如果是测试http，对于这些输出可以不用太关注，但是如果输出包含如下内容，则表示出现了异常响应，就需要注意判断请求异常</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Non-2xx or 3xx Responses: 20345</span><br></pre></td></tr></tbody></table></figure><p>这个就表示出现了非200 和3xx 响应的请求数量。都知道200是表示请求成功，3开头的一般是重定向。所以这种就表示出现了异常，可以查看日志，判断响应码，然后再解决问题。查看日志可以到具体的客户端wrk-utils目录下查看wrk-done.log 文件，此文件会显示具体的返回响应码。</p><h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><ol><li>吞吐量：吞吐量意味这台设备在每一秒以内所能够处理的最大流量或者说每一秒内能处理的数据包个数，或者说QPS、TPS之类。如果用带宽计量，单位是Mbps(Megabits per second)或者Gbps(Gigabits per second)<br>吞吐量测试是最简单的，连接数不用太大，每台几百个就可以，慢慢提高压测速率，注意延迟，直到测试出极限，压测时间也要慢慢提高。</li><li>时延： 时延是系统处理请求所需要的时间。在一个网络中，如果我们访问某一台服务器，一般经过大量的路由交换设备，在路上就要耗费很多时间，所以服务处理请求的时间也很重要。我们压测一般都是内网压测，所以延迟基本就是服务器处理时间，所以这个数值越低越好。<br>延迟不用单独测试，压测结果会包含延迟，重点关注平均延迟、50%请求的延迟、90%、99%、100%的延迟，可以看出整体状态。</li><li>新建连接速率： 新建连接速率指的是在每一秒以内服务器所能够处理的HTTP新建连连接请求的数量。用户每打开一个网页，访问一个服务器，在服务器看来会是1个甚至多个新建连接。而新建连接速率越高，就可以同时给更多的用户提供网络访问。比如设备的新建连接速率是1万，每人只会新建一个TCP连接，那么如果有1万人同时上网，那么所有的请求都可以在一秒以内完成，如果有1万1千人上网的话，那么前1万人可以在第一秒内完成，后1千个请求需要在下一秒才能完成。所以，新建连接速率高的服务器可以提供给更多人同时上网，提升用户的网络体验。<br>新建连接速率要用特殊方法测试，因为普通测试对于HTTP1.1来说，建立了TCP连接之后就不会断开了，后续的请求都是用的同一个TCP连接，所以这样没办法测出新建连接速率。所以我们测试的时候要改请求头，将Connection 设置为close，这样客户端每次请求都会新建TCP连接。在wrk-utils中测试可以编辑stats.lua文件，增加如下代码即可<blockquote><p>wrk.headers[“Connection”] = “close”</p></blockquote></li></ol><p>服务器端可以用特定监控工具，如果是centos7也可以用以下命令查看:</p><blockquote><p>sar -n TCP,ETCP 1</p></blockquote><p>每秒都会输出TCP相关数据，其中passive_opens时每秒钟创建的被动套接字数量，也就相当于服务器的新建连接数了。因为每一次HTTP请求新建一个TCP连接，所以可以直接使用这个值</p><ol start="4"><li>并发连接数：并发连接数就是指服务最大能够同时处理的连接会话个数。也就时能够维护的连接数的数量，现在普通的网站访问，一个用户一个浏览器一般会打开多个TCP连接，所以服务器这个指标越大，在一段时间内所能够允许同时上网的用户数越多。<br>这个指标测试和新建连接速率差不多，但不同点是TCP连接不断开，而是一直维持不关闭。所以新增的请求头close要去掉，保持默认，wrk通过-T设置超时时间，要加大这个值，而且服务器也要调整超时时间，避免断开TCP连接。<br>对于centos7可以使用ss -s查看当前TCP连接情况，也可以通过监控工具查看。执行ss -s命令输出如下：<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Total: 2346 (kernel 2506)</span><br><span class="line">TCP:   944 (estab 575, closed 298, orphaned 0, synrecv 0, timewait 122/0), ports 0</span><br><span class="line">Transport Total     IP        IPv6</span><br><span class="line">*         2506      -         -</span><br><span class="line">RAW       0         0         0</span><br><span class="line">UDP       9         7         2</span><br><span class="line">TCP       646       495       151</span><br><span class="line">INET      655       502       153</span><br><span class="line">FRAG      0         0         0</span><br></pre></td></tr></tbody></table></figure>其中TCP 中 estab 575就是当前的TCP已连接数量</li></ol><h4 id="注意要点"><a href="#注意要点" class="headerlink" title="注意要点"></a>注意要点</h4><ol><li>压测服务器一般要进行系统调优，centos默认的参数是没办法支持高并发的，这部分可以参考我之前的文章进行调整。</li><li>测试过程要时刻关注系统资源和负载，查看CPU、内存、磁盘和网络的使用情况，根据资源消耗调整压测参数。比如代理服务器可能会出现CPU过高，其他资源占用很少。有的服务器也可能出现软中断CPU过高，导致吞吐量上不去。有的可能会收到网线及网口限制。</li><li>压测要测出极限，也要测试正常使用状态的性能，避免突发流量导致服务异常。</li><li>一个压测工具可能会由于一些原因数值不准确，也可以使用其他工具进行压测，对比数据</li><li>压测要了解基本的TCP知识，比如握手挥手和TCP状态流转，要明白当前TCP各种状态出现的原因，比如大量TIME_WAIT一般是代理服务器出现，这个就可能导致压测性能上不去。</li><li>压测也要了解基本的HTTP知识，比如请求方式，请求类型，特定的请求头，这种都可能会对测试造成影响。</li><li>后端服务如果有必要可进行优化，比如通过监控进程线程的工具，或者火焰图工具，找到性能异常消耗的地方，进行性能调优</li></ol>]]></content>
      
      
      <categories>
          
          <category> 压力测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
            <tag> 压力测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL5.7 insert on duplicate key update 多线程死锁</title>
      <link href="/2022/11/18/MySQL5.7%20insert%20on%20duplicate%20key%20update%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81/"/>
      <url>/2022/11/18/MySQL5.7%20insert%20on%20duplicate%20key%20update%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>这篇文章不会过多介绍这几个代理，毕竟在网上可以搜到很多它们的优劣对比和适用场景，只要看几篇文章就可以初步了解。此处更专注于在高并发场景下它们的发挥和配置，而且只针对HTTP和TCP。</p><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>Nginx是我最先接触的，也是相对来说最熟悉的，可以用来部署一个静态WEB网站，最多的应该是用来当反向代理，提供负载均衡的服务。<br>Nginx的性能是非常高的，一个普通的服务器部署静态页面单机就可以几万QPS，要想再进一步提高性能，可以参考以下几个方面：</p><h4 id="系统调优"><a href="#系统调优" class="headerlink" title="系统调优"></a>系统调优</h4><p>可以看前面的文章 《<a href="https://turing.run/2022/08/18/%e9%ab%98%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b-1-linux%e7%b3%bb%e7%bb%9f%e8%b0%83%e4%bc%98/">Linux系统调优</a>》对系统参数做适当调整。</p><h4 id="配置调优"><a href="#配置调优" class="headerlink" title="配置调优"></a>配置调优</h4><p>经过系统调优可以确保系统的高并发，但是对于Nginx来说，还需要修改nginx.conf 主要配置文件里面的参数。</p><ol><li>worker_processes 可以调整工作进程数，工作进程数不是越多越好，当和CPU核数相同时可以充分利用CPU，但是我建议不要这样配置，而是空闲一部分CPU用来保持其他进程的正常使用。 比如8核CPU可以配置6或者4，这样Nginx最多也就占用75%的CPU。</li><li>worker_cpu_affinity 可以调整CPU亲和力，让不同的工作进程绑定到不同的核。这个地方就涉及到系统中断的概念了，参考上一篇《<a href="https://turing.run/2022/09/07/%e9%ab%98%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b-2-%e8%bd%af%e4%b8%ad%e6%96%ad/">软中断</a>》,可以尝试将工作的CPU绑定到软中断核或者避开软中断，再测试性能，这个比较我没测试过，而HAProxy中是推荐和网卡中断绑定到同一个CPU，不同的核上面。</li><li>event 部分</li></ol><ul><li>worker_connections 单个工作进程可以允许同时建立外部连接的数量，无论这个连接是外部主动建立的，还是内部建立的，这个数量会受到操作系统的最大文件数限制，一个TCP连接就相当于一个文件，如果进行了系统参数调优则直接修改就行，否则要先调整系统参数，这个数量可以调大一些，比如10240,65535之类，具体的数值要经过测试才会合理。</li></ul><ol start="4"><li>http 部分</li></ol><ul><li>keepalive_timeout 指定每个 TCP 连接最多可以保持多长时间，可以设置为60,75之类的，不要设置过大的数据，也不能太短，既要避免TCP连接过长时间不释放占用资源，也要避免过快关闭连接导致重新建立连接消耗资源。</li></ul><ol start="5"><li>server 部分</li></ol><ul><li>proxy_set_header Connection “”;  这个设置也很重要，作用是将http请求头Connection置空，不会传给真实后端服务器（上游服务器），因为proxy_set_header Connection 默认是’close’,会关闭长连接，也就是说客户端发的请求到了nginx是正常的，但是nginx和真实后端的http通信都是短连接，这个是很耗费性能的，而且由于此时nginx相当于客户端，还会受到端口数限制，高并发情况会产生大量连接，会有很多time_wait状态的TCP链接。proxy_http_version 1.1; 也需要设置。</li></ul><ol start="6"><li>upstream 部分</li></ol><ul><li>keepalive 开启与真实后端服务器（上游服务器）之间的连接池, 其数值为每个nginx worker可以保持的最大连接数，默认不设置，这是一个连接池，也是为了保证nginx的长连接，减少资源消耗。<blockquote><p>上面只是写了需要注意的几个参数，还有一些调优的并没有写出来，比如GZIP压缩、缓存配置、fastcgi和限流等等。完整的配置可以随便搜一下，重点关注上面几个，然后再根据测试情况适当调整参数。</p></blockquote></li></ul><h2 id="HAProxy"><a href="#HAProxy" class="headerlink" title="HAProxy"></a>HAProxy</h2><p>HAProxy也可以用来做负载均衡，但是不能做WEB server，是多线程模型，而Nginx是多进程的，虽然HA也支持多进程，但我测试发现有的时候多进程性能不如单进程好，而且HA会更多利用CPU内核操作，top命令可以看到内核占用百分比很大，相对Nginx来说性能差不多，可能会稍微好一点，但是不如Nginx模块丰富。</p><h4 id="系统调优-1"><a href="#系统调优-1" class="headerlink" title="系统调优"></a>系统调优</h4><p>参考Nginx提到的系统调优</p><h4 id="配置调优-1"><a href="#配置调优-1" class="headerlink" title="配置调优"></a>配置调优</h4><blockquote><p>我用HAProxy来做四层代理，也就是TCP层，所以配置会少很多，不过用来做负载均衡要注意IP透传之类的，让后端可以拿到真实IP</p></blockquote><ol><li>nbproc 配置进程数，建议配置一下进行测试，搭配cpu亲和绑定，有可能会提高性能，进程不要超过内核数，避免服务器满载。</li><li>cpu-map 绑定进程和CPU内核，可以将进程绑定到网卡中断CPU的不同内核上，再配合性能测试调整</li><li>maxconn 设定每个haproxy进程所接受的最大并发连接数，这个可以调大一些，几十万都可以</li><li>balance 负载均衡方式，可以通过业务情况调整</li></ol><h2 id="LVS"><a href="#LVS" class="headerlink" title="LVS"></a>LVS</h2><p>lvs已经在内核里面了，性能非常高，虽然这三个都支持4层负载均衡，但是LVS是不一样的。LVS支持DR、NAT、隧道、FULLNAT模式。</p><ul><li>DR模式：通过改写请求报文的目标MAC地址，将请求发送给真实服务器，而真实服务器将相应后的处理结果直接返还给客户端用户。极大地提高集群的伸缩性，但LB与RS必须在同一局域网环境。</li><li>NAT模式：通过网络地址转换，LB重写请求报文的目标地址，根据预设的调度算法，将请求分派给后端的真实服务器，真实服务器的响应报文处理之后，返回时必须通过LB，经过LB时报文的源地址被重写，再返回给客户。</li><li>隧道模式：LB把请求的报文通过IP隧道转发至真实服务器，而真实服务器将响应处理后直接返回给客户端用户。</li><li>FULLNAT模式：数据包进入时，除了做DNAT，还做SNAT，从而实现LVS-RealServer间可以跨vlan通讯，RealServer只需要连接到内网。</li></ul><p>从中可以看出除了隧道模式，其他的都是修改数据包中IP、MAC之类的操作，隧道模式是再封装一层，就像VPN一样，这就和Nginx之类有了一个很大区别：<strong>不用建立TCP连接</strong>，也就不用维护TCP，这样就能节省很多资源，继而提升性能。所以LVS性能要高与HAProxy和Nginx，但是LVS也有一些局限性，需要根据具体场景做取舍。</p><p>LVS不需要调优就有很高性能，当然支持网卡多队列，多核处理网卡中断会更好，如果想要有更高的性能，可以去搜一下DPDK。</p>]]></content>
      
      
      <categories>
          
          <category> 高并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高并发编程-3 负载均衡-Nginx-HAProxy-LVS</title>
      <link href="/2022/10/10/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-3%20%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-Nginx-HAProxy-LVS/"/>
      <url>/2022/10/10/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-3%20%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-Nginx-HAProxy-LVS/</url>
      
        <content type="html"><![CDATA[<p>这篇文章不会过多介绍这几个代理，毕竟在网上可以搜到很多它们的优劣对比和适用场景，只要看几篇文章就可以初步了解。此处更专注于在高并发场景下它们的发挥和配置，而且只针对HTTP和TCP。</p><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>Nginx是我最先接触的，也是相对来说最熟悉的，可以用来部署一个静态WEB网站，最多的应该是用来当反向代理，提供负载均衡的服务。<br>Nginx的性能是非常高的，一个普通的服务器部署静态页面单机就可以几万QPS，要想再进一步提高性能，可以参考以下几个方面：</p><h4 id="系统调优"><a href="#系统调优" class="headerlink" title="系统调优"></a>系统调优</h4><p>可以看前面的文章 《<a href="https://turing.run/2022/08/18/%e9%ab%98%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b-1-linux%e7%b3%bb%e7%bb%9f%e8%b0%83%e4%bc%98/">Linux系统调优</a>》对系统参数做适当调整。</p><h4 id="配置调优"><a href="#配置调优" class="headerlink" title="配置调优"></a>配置调优</h4><p>经过系统调优可以确保系统的高并发，但是对于Nginx来说，还需要修改nginx.conf 主要配置文件里面的参数。</p><ol><li>worker_processes 可以调整工作进程数，工作进程数不是越多越好，当和CPU核数相同时可以充分利用CPU，但是我建议不要这样配置，而是空闲一部分CPU用来保持其他进程的正常使用。 比如8核CPU可以配置6或者4，这样Nginx最多也就占用75%的CPU。</li><li>worker_cpu_affinity 可以调整CPU亲和力，让不同的工作进程绑定到不同的核。这个地方就涉及到系统中断的概念了，参考上一篇《<a href="https://turing.run/2022/09/07/%e9%ab%98%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b-2-%e8%bd%af%e4%b8%ad%e6%96%ad/">软中断</a>》,可以尝试将工作的CPU绑定到软中断核或者避开软中断，再测试性能，这个比较我没测试过，而HAProxy中是推荐和网卡中断绑定到同一个CPU，不同的核上面。</li><li>event 部分</li></ol><ul><li>worker_connections 单个工作进程可以允许同时建立外部连接的数量，无论这个连接是外部主动建立的，还是内部建立的，这个数量会受到操作系统的最大文件数限制，一个TCP连接就相当于一个文件，如果进行了系统参数调优则直接修改就行，否则要先调整系统参数，这个数量可以调大一些，比如10240,65535之类，具体的数值要经过测试才会合理。</li></ul><ol start="4"><li>http 部分</li></ol><ul><li>keepalive_timeout 指定每个 TCP 连接最多可以保持多长时间，可以设置为60,75之类的，不要设置过大的数据，也不能太短，既要避免TCP连接过长时间不释放占用资源，也要避免过快关闭连接导致重新建立连接消耗资源。</li></ul><ol start="5"><li>server 部分</li></ol><ul><li>proxy_set_header Connection “”;  这个设置也很重要，作用是将http请求头Connection置空，不会传给真实后端服务器（上游服务器），因为proxy_set_header Connection 默认是’close’,会关闭长连接，也就是说客户端发的请求到了nginx是正常的，但是nginx和真实后端的http通信都是短连接，这个是很耗费性能的，而且由于此时nginx相当于客户端，还会受到端口数限制，高并发情况会产生大量连接，会有很多time_wait状态的TCP链接。proxy_http_version 1.1; 也需要设置。</li></ul><ol start="6"><li>upstream 部分</li></ol><ul><li>keepalive 开启与真实后端服务器（上游服务器）之间的连接池, 其数值为每个nginx worker可以保持的最大连接数，默认不设置，这是一个连接池，也是为了保证nginx的长连接，减少资源消耗。<blockquote><p>上面只是写了需要注意的几个参数，还有一些调优的并没有写出来，比如GZIP压缩、缓存配置、fastcgi和限流等等。完整的配置可以随便搜一下，重点关注上面几个，然后再根据测试情况适当调整参数。</p></blockquote></li></ul><h2 id="HAProxy"><a href="#HAProxy" class="headerlink" title="HAProxy"></a>HAProxy</h2><p>HAProxy也可以用来做负载均衡，但是不能做WEB server，是多线程模型，而Nginx是多进程的，虽然HA也支持多进程，但我测试发现有的时候多进程性能不如单进程好，而且HA会更多利用CPU内核操作，top命令可以看到内核占用百分比很大，相对Nginx来说性能差不多，可能会稍微好一点，但是不如Nginx模块丰富。</p><h4 id="系统调优-1"><a href="#系统调优-1" class="headerlink" title="系统调优"></a>系统调优</h4><p>参考Nginx提到的系统调优</p><h4 id="配置调优-1"><a href="#配置调优-1" class="headerlink" title="配置调优"></a>配置调优</h4><blockquote><p>我用HAProxy来做四层代理，也就是TCP层，所以配置会少很多，不过用来做负载均衡要注意IP透传之类的，让后端可以拿到真实IP</p></blockquote><ol><li>nbproc 配置进程数，建议配置一下进行测试，搭配cpu亲和绑定，有可能会提高性能，进程不要超过内核数，避免服务器满载。</li><li>cpu-map 绑定进程和CPU内核，可以将进程绑定到网卡中断CPU的不同内核上，再配合性能测试调整</li><li>maxconn 设定每个haproxy进程所接受的最大并发连接数，这个可以调大一些，几十万都可以</li><li>balance 负载均衡方式，可以通过业务情况调整</li></ol><h2 id="LVS"><a href="#LVS" class="headerlink" title="LVS"></a>LVS</h2><p>lvs已经在内核里面了，性能非常高，虽然这三个都支持4层负载均衡，但是LVS是不一样的。LVS支持DR、NAT、隧道、FULLNAT模式。</p><ul><li>DR模式：通过改写请求报文的目标MAC地址，将请求发送给真实服务器，而真实服务器将相应后的处理结果直接返还给客户端用户。极大地提高集群的伸缩性，但LB与RS必须在同一局域网环境。</li><li>NAT模式：通过网络地址转换，LB重写请求报文的目标地址，根据预设的调度算法，将请求分派给后端的真实服务器，真实服务器的响应报文处理之后，返回时必须通过LB，经过LB时报文的源地址被重写，再返回给客户。</li><li>隧道模式：LB把请求的报文通过IP隧道转发至真实服务器，而真实服务器将响应处理后直接返回给客户端用户。</li><li>FULLNAT模式：数据包进入时，除了做DNAT，还做SNAT，从而实现LVS-RealServer间可以跨vlan通讯，RealServer只需要连接到内网。</li></ul><p>从中可以看出除了隧道模式，其他的都是修改数据包中IP、MAC之类的操作，隧道模式是再封装一层，就像VPN一样，这就和Nginx之类有了一个很大区别：<strong>不用建立TCP连接</strong>，也就不用维护TCP，这样就能节省很多资源，继而提升性能。所以LVS性能要高与HAProxy和Nginx，但是LVS也有一些局限性，需要根据具体场景做取舍。</p><p>LVS不需要调优就有很高性能，当然支持网卡多队列，多核处理网卡中断会更好，如果想要有更高的性能，可以去搜一下DPDK。</p>]]></content>
      
      
      <categories>
          
          <category> 高并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
            <tag> Linux </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高并发编程-2 软中断</title>
      <link href="/2022/09/07/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-2%20%E8%BD%AF%E4%B8%AD%E6%96%AD/"/>
      <url>/2022/09/07/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-2%20%E8%BD%AF%E4%B8%AD%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><blockquote><p>这篇文章前面相关内容都是<a href="https://xiaolincoding.com/os/1_hardware/soft_interrupt.html#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BD%AF%E4%B8%AD%E6%96%AD">小林coding文章</a>中的, 我太菜了而且对这些了解也不深，借用大佬的描述来了解软中断。</p></blockquote><p>软中断也是导致CPU利用率过高的一种原因，在高并发情况下，比如lvs和haproxy，这种代理的性能非常高，转发网络包的数据很快，但是有时候CPU没满，性能却上不去，这个就有可能是软中断导致的，因为有的机器软中断只会在其中几个核处理，当跑满这个CPU核时，系统已经没办法接收更多数据了，吞吐量也就上不去。</p><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><blockquote><p>在计算机中，中断是系统用来响应硬件设备请求的一种机制，操作系统收到硬件的中断请求，会打断正在执行的进程，然后调用内核中的中断处理程序来响应请求。</p></blockquote><ul><li>中断是一种异步的事件处理机制，可以提高系统的并发处理能力</li></ul><p>由于中断处理程序会<strong>打断其他进程的运行</strong>，为了减少对正常进程运行调度的影响，中断处理程序就需要尽可能快地运行<br>而且，中断处理程序在响应中断时，可能还会「<strong>临时关闭中断</strong>」，这意味着，如果当前中断处理程序没有执行完之前，系统中其他的中断请求都无法被响应，也就说中断有可能会丢失，所以中断处理程序要<strong>短且快</strong>。</p><h2 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h2><p>Linux 系统为了解决中断处理程序执行过长和中断丢失的问题，将中断过程分成了两个阶段，分别是「上半部和下半部分」。</p><ul><li><strong>上半部用来快速处理中断</strong>，一般会暂时关闭中断请求，主要负责处理跟硬件紧密相关或者时间敏感的事情。</li><li><strong>下半部用来延迟处理上半部未完成的工作</strong>，一般以「内核线程」的方式运行。</li></ul><h3 id="网卡接收数据包"><a href="#网卡接收数据包" class="headerlink" title="网卡接收数据包"></a>网卡接收数据包</h3><p>网卡收到网络包后，会通过<strong>硬件中断</strong>通知内核有新的数据到了，于是内核就会调用对应的中断处理程序来响应该事件，这个事件的处理也是会分成上半部和下半部。<br>上部分要做到快速处理，所以只要把网卡的数据读到内存中，然后更新一下硬件寄存器的状态，比如把状态更新为表示数据已经读到内存中的状态值。</p><p>接着，内核会触发一个软中断，把一些处理比较耗时且复杂的事情，交给「软中断处理程序」去做，也就是中断的下半部，其主要是需要从内存中找到网络数据，再按照网络协议栈，对网络数据进行逐层解析和处理，最后把数据送给应用程序。</p><p>所以，中断处理程序的上部分和下半部可以理解为：</p><ul><li><strong>上半部直接处理硬件请求，也就是硬中断</strong>，主要是负责耗时短的工作，特点是快速执行；</li><li><strong>下半部是由内核触发，也就说软中断</strong>，主要是负责上半部未完成的工作，通常都是耗时比较长的事情，特点是延迟执行；</li></ul><p>还有一个区别，硬中断（上半部）是会打断 CPU 正在执行的任务，然后立即执行中断处理程序，而软中断（下半部）是以内核线程的方式执行，并且每一个 CPU 都对应一个软中断内核线程，名字通常为「ksoftirqd/CPU 编号」，比如 0 号 CPU 对应的软中断内核线程的名字是 ksoftirqd/0</p><p>不过，软中断不只是包括硬件设备中断处理程序的下半部，一些内核自定义事件也属于软中断，比如内核调度等、RCU 锁（内核里常用的一种锁）等。</p><h2 id="排查软中断导致的性能问题"><a href="#排查软中断导致的性能问题" class="headerlink" title="排查软中断导致的性能问题"></a>排查软中断导致的性能问题</h2><p>在Centos中可以使用cat /proc/softirqs这个命令查看软中断的运行情况</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat /proc/softirqs</span><br><span class="line">                    CPU0       CPU1       CPU2       CPU3       CPU4       CPU5       CPU6       CPU7</span><br><span class="line">          HI:          4          0          0          0          0          0          0          0</span><br><span class="line">       TIMER:  532198655  459491084  471888996  564053345  463175289  446754977 2240971851  764917002</span><br><span class="line">      NET_TX:    1762126      38718      35142      43037      15838      18829     236006 2104955878</span><br><span class="line">      NET_RX:   15538808   16475626   18623151   17157923   11507031   16678401 2123413007   20772910</span><br><span class="line">       BLOCK:    1493868      26037     116512      23542   10995001    3787614        992    3937814</span><br><span class="line">BLOCK_IOPOLL:          0          0          0          0          0          0          0          0</span><br><span class="line">     TASKLET:         69          4          1          3         16          3          1  187326156</span><br><span class="line">       SCHED:  281338291  229366217  229384601  299741463  159036030  154905926  840990582  259952209</span><br><span class="line">     HRTIMER:          0          0          0          0          0          0          0          0</span><br><span class="line">         RCU:  375348322  332454839  344330542  398191959  318119015  311244918 1114199771  507090060</span><br></pre></td></tr></tbody></table></figure><ul><li>每一个 CPU 都有自己对应的不同类型软中断的<strong>累计运行次数</strong></li><li>第一列的内容，它是代表着软中断的类型，其中<strong>NET_RX 表示网络接收中断</strong>，<strong>NET_TX 表示网络发送中断</strong>。</li><li>从我这台服务器上可以看出CPU6的NET_RX次数很大，CPU7的NET_TX次数很大，这是因为我进行过多次压测，而这2个核就是在处理对应网卡的软中断。</li></ul><p>使用命令cat /proc/interrupts 可以查看硬中断的运行情况。</p><p>还有最常用的命令 top 可以查看CPU的使用情况，运行top后按1就可以查看每一个cpu核的使用情况, 这是一个正在接收压力的服务器情况，可以看到8个核的利用率</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">top - 18:27:09 up 100 days,  9:15,  1 user,  load average: 1.11, 0.54, 0.47</span><br><span class="line">Tasks: 196 total,   4 running, 191 sleeping,   0 stopped,   1 zombie</span><br><span class="line">%Cpu0  : 10.8 us, 11.4 sy,  0.0 ni, 77.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu1  : 10.1 us, 12.5 sy,  0.0 ni, 77.4 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu2  : 12.8 us, 14.1 sy,  0.0 ni, 73.2 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu3  :  9.5 us, 11.6 sy,  0.0 ni, 78.9 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu4  :  9.4 us,  4.7 sy,  0.0 ni, 86.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu5  : 16.5 us,  8.4 sy,  0.0 ni, 75.1 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu6  :  2.0 us,  1.7 sy,  0.0 ni, 45.1 id,  0.0 wa,  0.0 hi, 51.2 si,  0.0 st</span><br><span class="line">%Cpu7  :  9.2 us,  5.8 sy,  0.0 ni, 78.6 id,  0.0 wa,  0.0 hi,  6.4 si,  0.0 st</span><br><span class="line">KiB Mem : 15960012 total,   160152 free,  5327740 used, 10472120 buff/cache</span><br><span class="line">KiB Swap: 16777212 total, 16629500 free,   147712 used. 10256480 avail Mem</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line"> 6464 root      20   0 1499768  40612   1668 R  37.2  0.3 198:03.65 nginx</span><br><span class="line"> 6465 root      20   0 1503432  41740   1884 S  31.9  0.3 219:19.11 nginx</span><br><span class="line"> 6462 root      20   0 1494748  40528   1668 R  28.2  0.3 157:15.04 nginx</span><br><span class="line"> 6460 root      20   0 1492084  39168   1700 R  19.6  0.2 107:35.52 nginx</span><br><span class="line"> 6463 root      20   0 1489640  38520   1916 S  11.3  0.2  61:29.39 nginx</span><br></pre></td></tr></tbody></table></figure><p>其中</p><ul><li>us：用户空间占用CPU百分比（Host.cpu.user）</li><li>sy：内核空间占用CPU百分比（Host.cpu.system）</li><li>ni：用户进程空间内改变过优先级的进程占用CPU百分比</li><li>id：空闲CPU百分比（Host.cpu.idle）</li><li>wa：等待输入输出的CPU时间百分比</li><li>hi：硬件中断</li><li>si：软件中断</li><li>st：实时</li></ul><p>可以看到us sy每个核都有使用，但是使用率不高，而<strong>CPU6的si(软中断)很高</strong>，有50%多，这是因为发压的数据请求字节数很大，响应字节数很小，而上面我提过这台机器CPU6处理网络接收中断的，所以进入的数据流会很大，也就是会更占CPU。</p><p>从这个情况就可以扩展想一下，整体的CPU我们可以看到利用率不高，因为每个核的空闲百分比都很大（70%多），但是软中断的CPU6则利用率有50%多，所以这个软中断就很有可能成为性能瓶颈，也就是当请求量增加到一定程度，CPU6会直接被打满，而其他CPU核往往还有大量空闲。</p><p>这是部署Nginx的一个情况，HaProxy和LVS等等都一样，都会受到这个限制，<strong>所以当发现吞吐量上不去，而CPU利用率也比较低的时候就应该看看是不是软中断导致的</strong>。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>如果排查到软中断导致性能问题，解决方法可以从以下几方面考虑</p><ol><li><strong>硬件升级</strong>，CPU越好，那么处理速度越快，就能缓解这个问题，但是得加钱。</li><li><strong>网卡多队列、RSS</strong>，可以查看是否支持多队列，比如通过命令cat /proc/interrupts，如果是以下这种情况，可以看到有<strong>多个核都能处理网卡中断</strong>，那么这种性能会高很多。有的博客提到过可以修改参数配置，让网卡中断绑定到不同的核上，但是我试过不行，可能是操作不对或者系统不支持，后面也没深入研究，如果有这种需求可以再找一找相关资料。<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">       CPU0       CPU1       CPU2       CPU3       CPU4       CPU5       CPU6       CPU7</span><br><span class="line">35: 1157411688          0          0          0          0          0          0          0  IR-PCI-MSI-edge      eth0-TxRx-0</span><br><span class="line">36: 2199548159          0          0          0          0          0          0          0  IR-PCI-MSI-edge      eth0-TxRx-1</span><br><span class="line">37: 2210448541          0          0          0          0          0          0          0  IR-PCI-MSI-edge      eth0-TxRx-2</span><br><span class="line">38:  954381730          0          0          0          0          0          0          0  IR-PCI-MSI-edge      eth0-TxRx-3</span><br><span class="line">39: 3991435919          0          0          0          0          0          0          0  IR-PCI-MSI-edge      eth0-TxRx-4</span><br><span class="line">40: 2197207910          0          0          0          0          0          0          0  IR-PCI-MSI-edge      eth0-TxRx-5</span><br><span class="line">41: 2685654183          0          0          0          0          0          0          0  IR-PCI-MSI-edge      eth0-TxRx-6</span><br><span class="line">42: 2153260851          0          0          0          0          0          0          0  IR-PCI-MSI-edge      eth0-TxRx-7</span><br></pre></td></tr></tbody></table></figure></li><li><strong>DPDK</strong> ，DPDK 抛弃了传统的内核中断，采用轮询模式驱动( poll mode driver，PMD) 的方式直接操作网卡的接收和发送队列，将报文直接拷贝到用户空间，不再经过内核协议栈。这样就不会受到大量中断影响了，性能也会更高，比如可以看<a href="https://tech.meituan.com/2017/01/05/mgw.html">美团的MGV</a>，也可以搜一下其他相关的技术。</li><li>使用不同的负载均衡方式，DNS、LVS、硬件负载等等</li></ol>]]></content>
      
      
      <categories>
          
          <category> 高并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
            <tag> Linux </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高并发编程-1 Linux系统调优</title>
      <link href="/2022/08/18/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-1%20Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/"/>
      <url>/2022/08/18/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-1%20Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/</url>
      
        <content type="html"><![CDATA[<h2 id="必要性"><a href="#必要性" class="headerlink" title="必要性"></a>必要性</h2><ul><li>要想Linux发挥最高的能力，要保证项目达到最好的效果，系统参数和内核调优必不可少。</li><li>比如在写的WEB项目或者使用Nginx时，当遇到大量请求同时到来，往往会出现报错：Too many open files，这个原因就是Linux文件系统最大可打开文件数为1024，每个TCP连接都是操作socket，会打开文件，毕竟Linux一切皆文件。</li><li>还有Nginx、HAProxy作为反向代理时，需要将请求转到真实后端服务，那么就需要和后端建立TCP连接，这个时候如果后端只有一个服务，那么可建立的连接数理论上最多只能有65535，因为TCP连接由四元组区分，源IP、目的IP和目的端口都是固定的，只有源端口不固定，而端口数我们都知道最大只有65535。但是当实际测试中可能会发现最多只会有3万个连接，原因就是Linux也限制了可使用的端口范围。</li><li>当遇到SYN攻击、放大攻击、还有反向代理的服务器出现大量TIME_WAIT状态的连接处理也需要调整参数</li><li>还有TCP半连接队列大小、keepalive的时间等，也可以通过修改参数提高性能，降低消耗</li></ul><p>还有很多问题都可以通过调整参数来解决或者避免，此处不再一一细说。</p><blockquote><p><strong>注： 此处的参数都是我工作中搜集使用的，可能不适合所有情况</strong></p></blockquote><h2 id="系统参数调优"><a href="#系统参数调优" class="headerlink" title="系统参数调优"></a>系统参数调优</h2><p>需要编辑/etc/security/limits.conf 文件, 将文件末尾的数据替换成以下内容，重启后生效</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*                soft    nofile         2100000</span><br><span class="line">*                hard    nofile         2100000</span><br><span class="line">*                soft    memlock        unlimited</span><br><span class="line">*                hard    memlock        unlimited</span><br><span class="line">root             soft    nofile         2100000</span><br><span class="line">root             hard    nofile         2100000</span><br><span class="line">root             soft    memlock        unlimited</span><br></pre></td></tr></tbody></table></figure><p>修改这些数据可以使打开文件数变得更大，在网络上就可以建立更多的TCP连接，也就不会出现Too many open files错误了。<br>当然也可以通过ulimit -n修改，但是这个修改是临时的，会话终止就无效了。</p><h2 id="内核调优"><a href="#内核调优" class="headerlink" title="内核调优"></a>内核调优</h2><p>内核参数调优需修改 /etc/sysctl.conf 文件, 然后使用 sysctl -p 命令生效</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"># 可打开文件数大小</span><br><span class="line">fs.file-max=10485760</span><br><span class="line"># 单进程可打开的文件数</span><br><span class="line">fs.nr_open=10485760</span><br><span class="line"># 一个进程可以拥有的VMA(虚拟内存区域)的数量</span><br><span class="line">vm.max_map_count=262144</span><br><span class="line"># SYN半连接队列长度,syncookies启动则无效</span><br><span class="line">net.ipv4.tcp_max_syn_backlog=262144</span><br><span class="line"># accept队列长度</span><br><span class="line">net.core.somaxconn=32768</span><br><span class="line"># 每个网络接口接收数据包的速率比内核处理这些包的速率快时,允许送到队列的数据包的最大数目</span><br><span class="line">net.core.netdev_max_backlog=262144</span><br><span class="line"># 接收套接字缓冲区大小的缺省值,单位是字节</span><br><span class="line">net.core.rmem_default=262144</span><br><span class="line"># 发送套接字缓冲区大小的缺省值,单位是字节</span><br><span class="line">net.core.wmem_default=262144</span><br><span class="line"># 接收套接字缓冲区大小的最大值,单位是字节</span><br><span class="line">net.core.rmem_max=4194304</span><br><span class="line"># 发送套接字缓冲区大小的最大值,单位是字节</span><br><span class="line">net.core.wmem_max=4194304</span><br><span class="line"># 关闭ip转发功能不充当路由器</span><br><span class="line">net.ipv4.ip_forward=1</span><br><span class="line">net.ipv4.conf.all.send_redirects=0</span><br><span class="line">net.ipv4.conf.default.send_redirects=0</span><br><span class="line"># 是否允许服务绑定一个本机不存在的IP地址</span><br><span class="line">net.ipv4.ip_nonlocal_bind=1</span><br><span class="line"># 允许系统打开的端口范围</span><br><span class="line">net.ipv4.ip_local_port_range=1024 65535</span><br><span class="line"># 确保无人能修改路由表</span><br><span class="line">net.ipv4.conf.default.accept_redirects=0</span><br><span class="line">net.ipv4.conf.all.accept_redirects=0</span><br><span class="line">net.ipv4.conf.all.secure_redirects=0</span><br><span class="line">net.ipv4.conf.default.secure_redirects=0</span><br><span class="line"># 源地址校验 开启反向路径过滤</span><br><span class="line">net.ipv4.conf.default.rp_filter=1</span><br><span class="line">net.ipv4.conf.all.rp_filter=1</span><br><span class="line"># 开启重用,允许将TIME-WAIT sockets 重新用于新的TCP连接</span><br><span class="line">net.ipv4.tcp_tw_reuse=1</span><br><span class="line"># TIME-WAIT快速回收</span><br><span class="line">net.ipv4.tcp_tw_recycle=1</span><br><span class="line">net.ipv4.tcp_timestamps=1</span><br><span class="line"># TIME-WAIT数量</span><br><span class="line">net.ipv4.tcp_max_tw_buckets=300000</span><br><span class="line"># 开启SYN洪水攻击保护</span><br><span class="line">net.ipv4.tcp_syncookies=1</span><br><span class="line"># 内核放弃建立连接之前发送SYNACK 包的数量</span><br><span class="line">net.ipv4.tcp_synack_retries=1</span><br><span class="line"># 当keepalive 起用的时候,TCP 发送keepalive 消息的频度</span><br><span class="line">net.ipv4.tcp_keepalive_intvl=30</span><br><span class="line">net.ipv4.tcp_keepalive_time=900</span><br><span class="line">net.ipv4.tcp_keepalive_probes=3</span><br><span class="line"># 保持在FIN-WAIT-2状态的时间</span><br><span class="line">net.ipv4.tcp_fin_timeout=10</span><br><span class="line"># 防止孤儿连接过多,导致系统资源长时间被占用</span><br><span class="line">net.ipv4.tcp_max_orphans=131072</span><br><span class="line"># 接收缓冲区发送缓冲区大小</span><br><span class="line">net.ipv4.tcp_rmem=4096 4096 16777216</span><br><span class="line">net.ipv4.tcp_wmem=4096 4096 16777216</span><br><span class="line">net.ipv4.tcp_mem=786432 3145728  4194304</span><br><span class="line"># 防止icmp风暴</span><br><span class="line">net.ipv4.icmp_echo_ignore_broadcasts=1</span><br><span class="line"># 开启恶意icmp错误消息保护</span><br><span class="line">net.ipv4.icmp_ignore_bogus_error_responses=1</span><br></pre></td></tr></tbody></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>上述一些内核参数修改可能会导致产生异常，可以根据具体业务修改特定参数</li><li>比如tcp_timestamps和tcp_tw_recycle都设置为1，可能会导致在nat的网络环境访问服务器时会有不定时连接超时的问题。当多个客户端通过NAT方式联网并与服务端交互时，服务端看到的是同一个IP，这些客户端的时间戳可能存在差异，从服务端的视角看，便可能出现时间戳错乱的现象，进而直接导致时间戳小的数据包被丢弃。如果发生了此类问题，具体的表现通常是是客户端明明发送的SYN，但服务端就是不响应ACK，也就无法建立TCP连接。</li><li>比如tcp_tw_reuse开启TIME_WAIT重用，这个状态是主动发起TCP关闭的一端会出现，而且会持续2MSL时间之后才会回到初始状态，MSL值是数据包在网络中的最大生存时间，这段时间内这个端口是不能被重用的。正常来说只会影响客户端，服务端不收影响，但是当服务器充当反向代理，比如Nginx、Haproxy之类的就需要发起TCP连接，如果TIME_WAIT过多就无法建立新的连接，所以这些相关参数要适当调整。</li><li>还有TCP的keepalive，这个和我们通常了解的HTTP keepalive不是一回事，他是TCP的保活机制，如果两端的TCP连接一直没有数据交互，达到了触发TCP保活机制的条件，那么内核里的 TCP 协议栈就会发送探测报文,而Linux默认的保活时间是 7200 秒（2小时），也就 2 小时内如果没有任何连接相关的活动，则会启动保活机制，还会经过多次探测才会关闭，所以可以修改此参数避免TCP连接占用资源。</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>参数调优需谨慎，一不注意有可能会导致一些意想不到的问题，但是要想高并发，这些调优还是有必要的。网络方面的学习很重要，特别是TCP相关的知识更需要深入研究一下，之后再去调参数和项目开发则会事半功倍。</p>]]></content>
      
      
      <categories>
          
          <category> 高并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中String和byte[]转换长度异常情况</title>
      <link href="/2020/06/12/Java%E4%B8%ADString%E5%92%8Cbyte-%E8%BD%AC%E6%8D%A2%E9%95%BF%E5%BA%A6%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5/"/>
      <url>/2020/06/12/Java%E4%B8%ADString%E5%92%8Cbyte-%E8%BD%AC%E6%8D%A2%E9%95%BF%E5%BA%A6%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>工作中遇到，要拆分String成固定字节长度的几串字符。做法是转byte[]，拆分后再转String返回数据，但拆分后的String字节长度并不是前面固定的值</p></blockquote><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>  举个例子，一个String字符串要拆分成2个字符串，需要保证第一个字符串为5个字节，此处也只针对前半部分字符串进行讨论。</p><p>  以前学C语言还记得英文字符占1个字节，中文占2个字节，到java变成英文字符占2个字节，但实际上是字符编码不同影响所占字节数。此文章以UTF-8为准，Java中汉字占3个字节。</p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">"你是谁"</span>;</span><br><span class="line"><span class="comment">//原字符串全转为byte数组</span></span><br><span class="line"><span class="type">byte</span>[] b = str.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">//拆分的第一个byte数组，保证只有5个字节长度</span></span><br><span class="line"><span class="type">byte</span>[] b1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line"><span class="comment">//将原byte数组复制前5个字节到拆分的第一个数组b1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">    b1[i] = b[i];</span><br><span class="line">};</span><br><span class="line"><span class="comment">//b1数组转为需要返回的前半部分字符串，按理说b1数组是5个字节，那么str1应该也是5个字节</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b1, <span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">//对str1再次转换，转成byte[]</span></span><br><span class="line"><span class="type">byte</span>[] b2 = str1.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">//对相关数据输出展示</span></span><br><span class="line">System.out.println(<span class="string">"str原字符串："</span> + str);</span><br><span class="line">System.out.println(<span class="string">"str原字符串转换的byte数组b："</span> + Arrays.toString(b));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"str前5个字节的byte数组b1："</span> + Arrays.toString(b1));</span><br><span class="line">System.out.println(<span class="string">"str拆分后的前半部分字符串str1："</span> + str1);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"str1再次转为byte数组b2："</span> + Arrays.toString(b2));</span><br><span class="line">System.out.println(<span class="string">"str1再次转为byte数组b2的长度："</span> + b2.length);</span><br></pre></td></tr></tbody></table></figure><p>可以看一下输出</p><blockquote><p>str原字符串：你是谁<br>str原字符串转换的byte数组b：[-28, -67, -96, -26, -104, -81, -24, -80, -127]<br>str前5个字节的byte数组b1：[-28, -67, -96, -26, -104]<br>str拆分后的前半部分字符串str1：你�<br>str1再次转为byte数组b2：[-28, -67, -96, -17, -65, -67]<br>str1再次转为byte数组b2的长度：6</p></blockquote><p>问题出现了，前5个字节转换成的字符串str1，再转成byte[]变成6个字节了。</p><p>原因：汉字3个字节，原字符串3个汉字，共9个字节，切割前5个必然会把一个汉字分割，切分后的5个字节前3个按照UTF-8还可以转换为汉字，但是后2个已经无法组成一个汉字，我猜测若UTF-8中没有这2个字节组成的字符就会变成乱码，导致再次转换出现异常。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>  在进行转换时首先要确定字符编码，统一一种来进行开发，其次如果有切割字符串的操作（此处的切割指的是字节层面，并非单纯的切分），要尽量避免把一个汉字切分，可以适当移动字符串使得刚好不切割汉字。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode第4题：两个排序数组的中位数题解</title>
      <link href="/2018/09/19/leetcode%E7%AC%AC4%E9%A2%98%EF%BC%9A%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%E9%A2%98%E8%A7%A3/"/>
      <url>/2018/09/19/leetcode%E7%AC%AC4%E9%A2%98%EF%BC%9A%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>做到第四题，感觉好难，复杂度O(log(m+n))不好做，觉得该二分，做了一个小时放弃了，感觉没大一大二那种一直做下去，几个小时都不放弃的精力了，也可能是天气太热…..索性看了看官方的题解，顿时感觉茅塞顿开，我就把那题解放到这来吧。<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/#">原文链接</a></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>为了解决这个问题，我们需要理解“中位数的作用是什么”。在统计中，中位数被用来：</p><blockquote><p>将一个集合划分为两个长度相等的子集，其中一个子集中的元素总是大于另一个子集中的元素。</p></blockquote><p>如果理解了中位数的划分作用，我们就很接近答案了。</p><p>首先，让我们在任一位置  将 A 划分成两个部分：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   left_A                |        right_A</span><br><span class="line">A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>由于 A 中有 m 个元素， 所以我们有 m+1 种划分的方法（i=0∼m）。</p><p>我们知道：</p><blockquote><p>len(left_A)=i,len(right_A)=m−i.</p></blockquote><blockquote><p>注意：当 i=0 时，left_A 为空集， 而当 i=m 时, right_A 为空集。</p></blockquote><p>采用同样的方式，我们在任一位置 j 将 B 划分成两个部分：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  left_B                 |        right_B</span><br><span class="line">B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>将 left_A 和 left_B 放入一个集合，并将 rright_A 和 right_B 放入另一个集合。 再把这两个新的集合分别命名为 left_part 和 right_part：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      left_part          |        right_part</span><br><span class="line">A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]</span><br><span class="line">B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]</span><br></pre></td></tr></tbody></table></figure><p>如果我们可以确认：</p><blockquote><p>1.len(left_part)=len(right_part)<br>2.max⁡(left_part)≤min⁡(right_part)</p></blockquote><p>那么，我们已经将 {A,B} 中的所有元素划分为相同长度的两个部分，且其中一部分中的元素总是大于另一部分中的元素。那么：</p><p>median=max(left_part)+min(right_part)​ / 2</p><p>要确保这两个条件，我们只需要保证：</p><blockquote><p>1.i+j=m−i+n−j（或：m−i+n−j+1） 如果 n≥m，只需要使  i=0∼m, j=(m+n+1)/2−i<br>2.B[j−1]≤A[i] 以及 A[i−1]≤B[j]</p></blockquote><p>ps.1 为了简化分析，我假设 A[i−1],B[j−1],A[i],B[j]总是存在，哪怕出现 i=0，i=m，j=0，或是 j=n 这样的临界条件。 我将在最后讨论如何处理这些临界值。</p><p>ps.2 为什么 n≥m？由于0≤i≤m且 j=(m+n+1)/2−i，我必须确保 j 不是负数。如果 n&lt;m，那么 j 将可能是负数，而这会造成错误的答案。</p><p>所以，我们需要做的是：</p><blockquote><p>在 [0，m] 中搜索并找到目标对象 i，以使：<br>B[j−1]≤A[i] 且  A[i−1]≤B[j],其中 j=(m+n+1)/2−i</p></blockquote><p>接着，我们可以按照以下步骤来进行二叉树搜索：</p><p>设 imin=0，imax=m, 然后开始在 [imin,imax] 中进行搜索。<br>令 i=(imin+imax)/2​， j=(m+n+1)/2−i</p><p>现在我们有 len(left_part)=len(right_part)。 而且我们只会遇到三种情况：</p><p>B[j−1]≤A[i] 且 A[i−1]≤B[j]：<br>这意味着我们找到了目标对象 i，所以可以停止搜索。</p><p>B[j−1]&gt;A[i]：<br>这意味着 A[i] 太小，我们必须调整 i 以使 B[j−1]≤A[i]。<br>我们可以增大 i 吗？<br>是的，因为当 i 被增大的时候，j 就会被减小。<br>因此 B[j−1] 会减小，而 A[i] 会增大，那么 B[j−1]≤A[i] 就可能被满足。<br>我们可以减小 i 吗？<br>不行，因为当 i 被减小的时候，j 就会被增大。<br>因此 B[j−1] 会增大，而 A[i] 会减小，那么 B[j−1]≤A[i] 就可能不满足。<br>所以我们必须增大 i。也就是说，我们必须将搜索范围调整为 [i+1,imax]。 因此，设imin=i+1并转到步骤 2。</p><p>A[i−1]&gt;B[j]： 这意味着 A[i−1] 太大，我们必须减小 i 以使 A[i−1]≤B[j]。 也就是说，我们必须将搜索范围调整为 [imin,i−1]。<br>因此，设 imax=i−1，并转到步骤 2。</p><p>当找到目标对象 i 时，中位数为：</p><blockquote><p>max(A[i−1],B[j−1]),  当 m+n 为奇数时</p></blockquote><blockquote><p>max⁡(A[i−1],B[j−1])+min⁡(A[i],B[j])/2, ​,  当 m+n为偶数时</p></blockquote><p>现在，让我们来考虑这些临界值 i=0,i=m,j=0,j=n，此时 A[i−1],B[j−1],A[i],B[j] 可能不存在。 其实这种情况比你想象的要容易得多。</p><p>我们需要做的是确保 max(left_part)≤min(right_part)。 因此，如果 i 和 j 不是临界值（这意味着 A[i−1],B[j−1],A[i],B[j]全部存在）, 那么我们必须同时检查 B[j−1]≤A[i] 以及 A[i−1]≤B[j] 是否成立。 但是如果 A[i−1],B[j−1],A[i],B[j] 中部分不存在，那么我们只需要检查这两个条件中的一个（或不需要检查）。 举个例子，如果 i=0，那么 A[i−1]不存在，我们就不需要检查 A[i−1]≤B[j] 是否成立。 所以，我们需要做的是：</p><blockquote><p>在 [0，m] 中搜索并找到目标对象 i，以使：<br>(j=0 or i=m or B[j−1]≤A[i]) 或是 (i=0 or j=n or A[i−1]≤B[j]), 其中 j=(m+n+1)/2−i</p></blockquote><p>在循环搜索中，我们只会遇到三种情况：</p><blockquote><p>(j=0 or i=m or B[j−1]≤A[i])) 或是(i=0 or j=n or A[i−1]≤B[j])这意味着 i 是完美的，我们可以停止搜索。<br>j&gt;0 and i&lt;m and B[j−1]&gt;A[i]这意味着 i 太小，我们必须增大它。<br>i&gt;0 and j&lt;n and A[i−1]&gt;B[j]这意味着 i 太大，我们必须减小它。</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span>[] B)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> A.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> B.length;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) { <span class="comment">// to ensure m&lt;=n</span></span><br><span class="line">            <span class="type">int</span>[] temp = A; A = B; B = temp;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> m; m = n; n = tmp;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">iMin</span> <span class="operator">=</span> <span class="number">0</span>, iMax = m, halfLen = (m + n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (iMin &lt;= iMax) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (iMin + iMax) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> halfLen - i;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; iMax &amp;&amp; B[j-<span class="number">1</span>] &gt; A[i]){</span><br><span class="line">                iMin = i + <span class="number">1</span>; <span class="comment">// i is too small</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; iMin &amp;&amp; A[i-<span class="number">1</span>] &gt; B[j]) {</span><br><span class="line">                iMax = i - <span class="number">1</span>; <span class="comment">// i is too big</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> { <span class="comment">// i is perfect</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">maxLeft</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) { maxLeft = B[j-<span class="number">1</span>]; }</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) { maxLeft = A[i-<span class="number">1</span>]; }</span><br><span class="line">                <span class="keyword">else</span> { maxLeft = Math.max(A[i-<span class="number">1</span>], B[j-<span class="number">1</span>]); }</span><br><span class="line">                <span class="keyword">if</span> ( (m + n) % <span class="number">2</span> == <span class="number">1</span> ) { <span class="keyword">return</span> maxLeft; }</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> <span class="variable">minRight</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (i == m) { minRight = B[j]; }</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j == n) { minRight = A[i]; }</span><br><span class="line">                <span class="keyword">else</span> { minRight = Math.min(B[j], A[i]); }</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> (maxLeft + minRight) / <span class="number">2.0</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>复杂度分析</p><p>时间复杂度：O(log⁡(min(m,n)))，<br>首先，查找的区间是 [0,m]。 而该区间的长度在每次循环之后都会减少为原来的一半。 所以，我们只需要执行 log⁡(m) 次循环。由于我们在每次循环中进行常量次数的操作，所以时间复杂度为 O(log⁡(m))。 由于 m≤n，所以时间复杂度是 O(log⁡(min(m,n)))。</p><p>空间复杂度：O(1)， 我们只需要恒定的内存来存储 9 个局部变量， 所以空间复杂度为 O(1)。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法总结</title>
      <link href="/2018/09/18/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2018/09/18/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>刷leetcode碰到一个难题，里面用到了分治法，想到了归并排序，觉得以前学的排序基本忘得差不多了，特别是快排，直接sort()调用，自己基本实现不了，索性重新复习一遍</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>归并排序(Merging Sort)就是将两个或两个以上的有序表合并成一个有序表的过程。将两个有序表合并成一个有序表的过程称为2-路归并，2-路归并最为简单和常用。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>假设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列的长度是１，然后两两归并，得到[n/2]个长度为2或１的有序子序列；再两两归并,…如此重复，直到得到一个长度为n的有序子序列为止。</p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>1.排序：归并排序的时间复杂度是O(nlog2n)，当有n个记录时，需要进行log2n次归并排序，每一次归并，关键字比较次数不超过n，元素移动次数都是n，因此是nlog2n。<br>归并排序是稳定排序(在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的)，可以用于链式结构。<br>2.找逆序对数，以前打ACM碰到过好几次，第一次见到这种题觉得好难，这就说明对归并排序理解不深，这点在紫书上也提到过。当然也可以通过树状数组解决这类问题。</p><h3 id="代码＋解释"><a href="#代码＋解释" class="headerlink" title="代码＋解释"></a>代码＋解释</h3><p><img src="https://i.loli.net/2018/09/19/5ba1c26ba50b3.png" alt="归并排序"><br>对于这张图，将原序列分解为n个子序列，然后开始比较归并，对于分解可以用二分＋递归来实现，合并也是一样。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法实现</span></span><br><span class="line"><span class="comment">//采用紫书代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span>* A, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span>* T)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(y - x &gt; <span class="number">1</span>) {</span><br><span class="line">        <span class="type">int</span> m = x + (y - x) / <span class="number">2</span>;     <span class="comment">//划分</span></span><br><span class="line"><span class="type">int</span> p = x, q = m, i = x;    </span><br><span class="line"><span class="built_in">merge_sort</span>(A, x, m, T);      <span class="comment">//递归求解</span></span><br><span class="line"><span class="built_in">merge_sort</span>(A, m, y, T);      <span class="comment">//递归求解</span></span><br><span class="line"><span class="keyword">while</span>(p &lt; m || q &lt; y) {</span><br><span class="line">    <span class="keyword">if</span>(q &gt;= y || (p &lt; m &amp;&amp; A[p] &lt;= A[q])) T[i++] = A[p++];     <span class="comment">//从左半数组复制到临时空间</span></span><br><span class="line">    <span class="keyword">else</span> T[i++] = A[q++];                                      <span class="comment">//从右半数组复制到临时空间</span></span><br><span class="line">　　　　<span class="comment">// else T[i++] = A[q++], cnt += m - p;                     //这一行就可以实现求逆序对数的问题，其中cnt要先清零</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(i = x; i &lt; y; i++) A[i] = T[i];                            <span class="comment">//从辅助空间复制回A数组</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UEFI启动模式的电脑安装Win10和Ubuntu双系统</title>
      <link href="/2018/03/23/UEFI%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%94%B5%E8%84%91%E5%AE%89%E8%A3%85Win10%E5%92%8CUbuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2018/03/23/UEFI%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%94%B5%E8%84%91%E5%AE%89%E8%A3%85Win10%E5%92%8CUbuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="文章简介"><a href="#文章简介" class="headerlink" title="文章简介"></a>文章简介</h2><p>目前有很多教程安装Ubuntu，但大多数都比较老，而且步骤很繁琐，有的还是错的，偶然看到一篇文章写的很详细而且足够简洁，我获得作者授权后，将他的博文转载至此，<a href="https://blog.csdn.net/ysy950803/article/details/52643737">原文链接</a>，作者<a href="https://blog.csdn.net/ysy950803">针叶</a>。</p><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p>双硬盘（固态+机械，并且原Windows的引导盘在固态）要装双系统，此文不适用（否则会出现安装完Ubuntu后看不到grub菜单或者搞出来grub菜单后看不到Windows Boot Manager选项，因为你把Ubuntu的引导装在了机械硬盘，和Win的引导不在一个盘），请移步大神们的文章：<br>非UEFI：<br><a href="http://www.jianshu.com/p/c6750e459a94">http://www.jianshu.com/p/c6750e459a94</a><br><a href="http://jingyan.baidu.com/article/e75aca8551621a142edac6db.html">http://jingyan.baidu.com/article/e75aca8551621a142edac6db.html</a><br>最后应该把固态硬盘分一部分出来作为Ubuntu的引导分区（因为下文所讲的是efi引导，最好不要挂载efi了，而是/boot）。</p><p>UEFI：<br>通过BIOS设置切换硬盘启动顺序，以进入不同系统：<br><a href="http://www.cnblogs.com/willnote/p/6725594.html">http://www.cnblogs.com/willnote/p/6725594.html</a></p><p>我个人不太喜欢虚拟机下安装系统，一来运行效率不行，二来原生体验不行。</p><p>原本我的电脑是Windows 10专业版，为了体验和学习Linux，我给本本安装了Ubuntu 16.0.4 LTS（目前官网能下载到的最新版本），于是各种搜安装教程，感觉各种复杂。</p><p>后来我发现了他们复杂的原因，我仔细看了下这些教程文章的时间，很多都是好几年前的教程，就算是时间很近的，也是抄来抄去，长篇大论无奇不有。其实那都是因为以前的电脑都不是UEFI启动，而是Legacy，大家都知道Win8以后都有快速启动，必须得依靠UEFI。</p><p>然而随着UEFI的普及，现在你去买笔记本电脑几乎买不到不是UEFI的，这是一种先进安全的启动模式，而且Ubuntu本身也是支持UEFI启动的，所以安装双系统是非常简单的事情。</p><p>第一步最重要的就是你要分区，Linux没有什么C盘D盘的概念，只有分区挂载目录的概念，所以你在Windows下只需要分出一块较大的未分配空间就行，记住不要去格式化，保证其“未分配”属性（Linux的文件系统和Win是不一样的，NTFS和FAT32都不适用）。<br>用Win自带的磁盘管理不能合并不相邻的未分配空间，所以你要想C盘割一点，D盘割一点，再合在一起那是不行的，解决办法是在WinPE系统环境下使用无损分区软件，去合并不同区域的空闲空间，这里不赘述。（如果不愿使用PE的，直接分割已有分区即可，比如你最后一个分区是F盘，分出几十个GB就行，当然前提是你原本空间够大）</p><p>第二，你必须要有一个U盘（光盘就算了太麻烦了），然后使用软碟通或者USBWriter把iso系统镜像文件烧录进去，这是比较传统的方法，但既然我们UEFI启动，那就根本不需要刻录这么麻烦的工作了，<strong>直接将iso里的所有文件解压至U盘即可</strong>。<br><img src="https://i.loli.net/2018/03/23/5ab517e5ac0cb.jpg" alt="图片"><br>大家可以看到，Ubuntu的镜像文件里本身就有EFI文件夹，说明其实支持UEFI引导安装的。</p><p>然后记得关闭Windows的快速启动，重启电脑，我是Dell的本，开机按F2进入BIOS设置，F12进入启动设置，其它电脑类似，大家自行了解。</p><p>进入BIOS设置后，关闭Security Boot（我这里Dell的本是按F12，再选最后那个Change Mode……，然后改为UEFI, Security Boot Off），最后选择UEFI下的U盘启动，所以整个过程根本不用改为Legacy里的HardDisk启动，那是个既老又慢的启动方式。</p><p>选中USB启动，回车后即进入Ubuntu安装流程，<br>前面几步我就不说了，按照正常的步骤，<strong>如果你选择了安装更新和第三方软件，那么一定要记得联网，否则会卡死在最后的进度条上，所以最好不要勾选</strong>。另外，不要选择“与其它系统共存”那一项，而选择最后那个“其它选项（创建自己的分区）”。</p><p>最最最关键的就是分区这一步，这一步直接影响你安装双系统是否成功！下面依次点击新建分区表来挂载分区。</p><p><strong>swap交换空间</strong>，这个也就是虚拟内存的地方，选择<strong>主分区</strong>和<strong>空间起始位置</strong>。如果你给Ubuntu系统分区容量足够的话，最好是能给到你物理内存的2倍大小，像我8GB内存，就可以给个16GB的空间给它，这个看个人使用情况，太小也不好，太大也没用。（其实我只给了8GB，没什么问题）</p><p>新建<strong>efi系统分区</strong>，选中<strong>逻辑分区</strong>（这里不是主分区，请勿怀疑，老式的boot挂载才是主分区）和<strong>空间起始位置</strong>，大小最好不要小于256MB，系统引导文件都会在里面，我给的512MB，它的作用和boot引导分区一样，但是boot引导是默认grub引导的，而efi显然是UEFI引导的。<strong>不要按照那些老教程去选boot引导分区，也就是最后你的挂载点里没有“/boot”这一项，否则你就没办法UEFI启动两个系统了</strong>。</p><p>挂载“**/home<strong>”，类型为</strong>EXT4日志文件系统<strong>，选中</strong>逻辑分区<strong>和</strong>空间起始位置**，这个相当于你的个人文件夹，类似Windows里的User，如果你是个娱乐向的用户，我建议最好能分配稍微大点，因为你的图片、视频、下载内容基本都在这里面，这些东西可不像在Win上面你想移动就能移动的。<br>总的来说，最好不要低于8GB，我Ubuntu分区的总大小是64GB，这里我给了12GB给home。<br>（这里特别提醒一下，Ubuntu最新发行版不建议强制获取Root权限，因为我已经玩崩过一次。所以你以后很多文档、图片、包括免安装软件等资源不得不直接放在home分支下面。你作为图形界面用户，只对home分支有完全的读写执行权限，其余分支例如usr你只能在终端使用sudo命令来操作文件，不利于存放一些直接解压使用的免安装软件。因此，建议home分支多分配一点空间，32GB最好……）</p><p>挂载“**/usr<strong>”，类型为</strong>EXT4日志文件系统<strong>，选中</strong>逻辑分区<strong>和</strong>空间起始位置**，这个相当于你的软件安装位置，Linux下一般来说安装第三方软件你是没办法更改安装目录的，系统都会统一地安装到/usr目录下面，因此你就知道了，这个分区必须要大，我给了32GB。</p><p>最后，挂载“**/<strong>”，类型为</strong>EXT4日志文件系统<strong>，选中</strong>逻辑分区<strong>和</strong>空间起始位置**，<br>因为除了home和usr还有很多别的目录，但那些都不是最重要的，“/”就把除了之前你挂载的home和usr外的全部杂项囊括了，大小也不要太小，最好不低于8GB。如果你非要挨个仔细分配空间，那么你需要知道这些各个分区的含义（Linux(ubuntu)分区挂载点介绍）<br>不过就算你把所有目录都自定义分配了空间也必须要给“/”挂载点分配一定的空间。</p><blockquote><p>分配好各个挂载点后，还有一个至关重要的步骤，那就是选择“<strong>安装引导启动器的设备</strong>”，默认是错&gt;误的，既然我们为Ubuntu分配了efi系统引导分区，那么显然，这里应该把它改成刚刚第2步分配efi引&gt;导的那个分区（比如我安装时它是/dev/sda7，那么我就选这个）。</p></blockquote><p>如此一来，成功一大半，接下来点击安装，等待差不多半小时即可。这个就看电脑配置和网速了。</p><p>这里再多说一句，如果你安装进度条卡在最后的update-notifier-common，请拔掉你的网线也就是断网，然后再连接，多等一会儿就会好。你点一下那行字就会看到安装详情，只要详情在刷新就没问题。</p><p>安装成功后，会提示你拔掉U盘并且重启，重启后记得进入BIOS改回UEFI Security Boot On模式，也就是重新开启Security Boot，然后再重启你就可以看到选择系统的启动引导界面了，一般来说：<br>第一个是Ubuntu，选这个进入Ubuntu系统，<br>第二个是Ubuntu高级选项，<br>第三个是Windows Boot Manager，也就是启动你的Win10，<br>第四个不好意思忘了。</p><p>默认10s自动进入第一个，如果你不动的话。<br>以上教程比网上一些图文更系统更有用，只要你耐心看完，保证万无一失。安装成功后，Win10的快速启动也可以重新开启。</p><p>最最最后，如果大家装好系统后想要恢复U盘到普通状态的话，请看我的另一篇博文：<a href="https://blog.csdn.net/ysy950803/article/details/52642887">解决U盘制作Ubuntu系统安装盘后无法格式化且容量无法恢复</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> Win10 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单点餐app的实现</title>
      <link href="/2017/12/30/%E7%AE%80%E5%8D%95%E7%82%B9%E9%A4%90app%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2017/12/30/%E7%AE%80%E5%8D%95%E7%82%B9%E9%A4%90app%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这学期开了学Android的课，以前也没看过相关的知识，刚好前两周课设用来检验一下学习的成果，就做了一个点餐的app，实现了和服务器后台的交互，数据库用的mysql，用户使用app，商家使用web页面，由于自己弱渣，用了很多别人的设计和代码，如有侵权，请联系我。</p><h2 id="APP设计"><a href="#APP设计" class="headerlink" title="APP设计"></a>APP设计</h2><p>Android第一次学，代码写的很乱，请不要介意。</p><p><a href="https://github.com/Hiccup1/ELapp">Abdroid项目源码</a>（后台源码在下面）</p><h3 id="界面展示"><a href="#界面展示" class="headerlink" title="界面展示"></a>界面展示</h3><p>这是主要的界面，还有一些展示订单的界面，有一些没用的特效界面。。</p><div><img src="https://i.loli.net/2017/12/30/5a4719de93a12.png" height="330" width="190"><img src="https://i.loli.net/2017/12/30/5a4719c858184.png" height="330" width="190"><img src="https://i.loli.net/2017/12/30/5a4719d4f0b19.png" height="330" width="190"> </div><h3 id="设计简要"><a href="#设计简要" class="headerlink" title="设计简要"></a>设计简要</h3><p>第一次做，写的乱七八糟，基本一个页面一个Activity，底部菜单栏用的Tabhost+Activity实现，有些设计用的github上的代码，由于和服务器交互，读取的是数据库的内容，所以Listview使用最频繁，每加载一个页面都会get/post服务器，对于网络延迟的问题就加了一个Dialog等待加载。java部分写的比较乱，将就着看吧。。</p><h3 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h3><p>Github项目中包含了apk文件，可以直接拿来用，不过服务器是我自己的，现在快到期了，可能停止服务。你也可以把后台部署到自己的服务器上来使用，因为后台是用java写的，所以用Tomcat来用就可以。</p><p>如果使用自己的服务器，就要到Android项目中app\src\main\java\com\example\user\util\Data.java 中修改自己的域名或者说ip，这样就可以访问你自己服务器的数据了。war文件和mysql数据库的创建文件也在后台项目中，源码地址在下面。</p><p>其中mysql中图片存储使用的都是外链，你可以使用七牛云，腾讯云，或者其他可提供图片外链的服务。其他数据可以通过商家web界面添加或者直接对数据库操作。</p><h2 id="后台实现"><a href="#后台实现" class="headerlink" title="后台实现"></a>后台实现</h2><p>大二学的java，自己学了一点点java web的知识，这次课设拿来练手，就用eclipse写了后台部署到服务器上，代码稍微比Android好看一些。和app的交互用的servlet接收发送json信息。然后对数据库进行增删改查，实现完整的操作。</p><p>mysql的连接在util类里，可以修改mysql的密码和用户名等等。</p><p><a href="https://github.com/Hiccup1/ELjava">后台项目源码</a></p><h3 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h3><p>浏览器访问界面实现商家的注册和登录，可以对自己店铺的菜品类别等等进行修改，也可以实现接单删除等功能，其他的自己去看。</p><h3 id="设计简要-1"><a href="#设计简要-1" class="headerlink" title="设计简要"></a>设计简要</h3><ul><li>util包含数据库连接和json的解析              </li><li>servlet是对app的连接                      </li><li>action里面写了web页面的servlet，实现店铺数据的增删改查               </li><li>model写了数据库中表的信息，get+set            </li><li>dao+imp实现增删改查的具体操作         </li></ul><h3 id="使用注意-1"><a href="#使用注意-1" class="headerlink" title="使用注意"></a>使用注意</h3><p>我写的时候eclipse myeclipse都使用过，直接导入自己的IDE可能出很多问题，慢慢百度或者各种调整说不定能解决，那就可以修改了</p><p>web页面用的jsp，也可以直接看，简单的操作都实现了，具体的自己研究。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果有什么问题可以直接联系我，或者说有错也可以提出，修改和测试才是漫长的过程。       </p>]]></content>
      
      
      <categories>
          
          <category> app </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔：递归的妙用&lt;1&gt;</title>
      <link href="/2017/12/09/%E9%9A%8F%E7%AC%94%EF%BC%9A%E9%80%92%E5%BD%92%E7%9A%84%E5%A6%99%E7%94%A8-1/"/>
      <url>/2017/12/09/%E9%9A%8F%E7%AC%94%EF%BC%9A%E9%80%92%E5%BD%92%E7%9A%84%E5%A6%99%E7%94%A8-1/</url>
      
        <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>昨天闲的蛋疼在百度知道回答问题，看到一个很有趣的题目，要求用递归实现如下的输出</p><blockquote><p>1<br>5 2<br>8 6 3<br>10 9 7 4      </p></blockquote><p>想了一段时间， 自己写了个代码，差不多实现了这功能，却又懒得去优化一下。好久没做算法题目lower_bound的参数都记得不太清楚了，不过还好自己写出来的没错，程序成功运行。</p><h2 id="代码-结果"><a href="#代码-结果" class="headerlink" title="代码+结果"></a>代码+结果</h2><blockquote><p>代码如下                      </p></blockquote><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cctype&gt;#define LL long longusing namespace std;const LL inf = 1e18;const LL mod = 1e9+7;int s[10] = {1, 3, 6, 10, 15, 21, 27};int m;void f(int n, int k, int cnt) {    if(n == 1) {        return;    }    else if(cnt == 0) {        cnt = m - k - 1;        k = m;        f(cnt + 1, k, cnt);        printf("%d\n", cnt + 1);    }else {        f(n + k, k - 1, cnt - 1);        printf("%d ", n + k);    }}int main() {    //1 3 6 10 15 21 27    //1 2 3 4  5  6  7    //s = (1 + n) * n / 2    int n;    while(scanf("%d", &amp;n) != EOF) {        int k = lower_bound(s, s + 7, n) - s;        m = k;        f(k + 1, k, k);        printf("%d\n", k + 1);    }    return 0;}</code></pre><blockquote><p>结果如图<br><img src="https://i.loli.net/2017/12/09/5a2becfde7e04.png" alt="结果"></p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>有时间做做这类型的题目也很有意思，锻炼一下思维还是有好处的，这个写的比较烂，如果有更好的方法，不如说出来大家共同探讨一下。</p>]]></content>
      
      
      <categories>
          
          <category> 递归 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA实现微信支付</title>
      <link href="/2017/11/21/JAVA%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/"/>
      <url>/2017/11/21/JAVA%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间在做一个微信公众号，需要用到微信支付的接口，第一次用，果然和前面写其他接口经历一样，好繁琐的操作。去找了相关资料，看了看文档，越看越复杂，大多数博客上面的总是缺着一部分跑不起来，官方demo又好复杂，索性自己好好搞一次。</p><h2 id="需求准备"><a href="#需求准备" class="headerlink" title="需求准备"></a>需求准备</h2><p>1.首先一个公众号（服务号），也可以企业号，订阅号没有支付权限（权限可以查文档），可以去微信公众平台申请，而且需要认证，一年300<br>2.一个域名，必须经过ICP备案，必须备案，很重要，也就是说还需要一个服务器，备案大概1个月<br>3.<a href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=7_1">微信支付开发文档</a><br>4.商户平台账号，也就是微信支付平台，前段时间微信支付单独迁移到了商户平台，所以需要单独申请</p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>1.前提公众号的配置已经完成，比如在公众平台的服务器配置，接口域名配置，授权配置等等。还有商户平台的支付授权目录填写。这些都可以通过文档或者搜索引擎找到。<br>2.接下来需要调用统一下单接口获取预支付id（prepay_id）<br>其中需要很多参数，参数的具体含义可见<a href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=9_1">文档</a><br>这是<a href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=4_3">签名生成算法</a>大多数错误都是由于签名错误             </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//微信支付</span></span><br><span class="line"><span class="type">String</span> <span class="variable">nonceStr</span> <span class="operator">=</span> <span class="string">"2D8264ILTKCH16CQ2502SI8ZNMTM67VS"</span>;<span class="comment">//随机字符串,可以自己生成</span></span><br><span class="line"><span class="type">String</span> <span class="variable">MCHID</span> <span class="operator">=</span> <span class="string">"11111111"</span>;    <span class="comment">//商户号，商户平台注册</span></span><br><span class="line"><span class="type">String</span> <span class="variable">WX_APPID</span> <span class="operator">=</span> ;  <span class="comment">//APPID，也就是公众平台APPID</span></span><br><span class="line"><span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="string">"xx"</span>;  <span class="comment">//商品描述</span></span><br><span class="line"><span class="type">String</span> <span class="variable">WX_PAY_CALLBACK</span> <span class="operator">=</span> <span class="string">""</span>;<span class="comment">//异步接收微信支付结果通知的回调地址</span></span><br><span class="line"><span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> request.getRemoteAddr(); <span class="comment">//用户端ip</span></span><br><span class="line"><span class="type">String</span> <span class="variable">orderSn</span> <span class="operator">=</span> String.valueOf((<span class="type">int</span>)(<span class="keyword">new</span> <span class="title class_">Date</span>().getTime()));<span class="comment">//商户订单号,这用的是时间</span></span><br><span class="line"><span class="type">String</span> <span class="variable">relAmount</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//订单总金额，单位为分</span></span><br><span class="line"><span class="type">String</span> <span class="variable">openid</span> <span class="operator">=</span> user.getOpenid();  <span class="comment">//用户openid</span></span><br><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">""</span>;  <span class="comment">//商户平台API秘钥</span></span><br><span class="line"><span class="comment">// 加密，这里只列举必填字段</span></span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">map.put(<span class="string">"body"</span>, body);<span class="comment">//商品描述</span></span><br><span class="line">map.put(<span class="string">"mch_id"</span>, MCHID);<span class="comment">//商户平台id</span></span><br><span class="line">map.put(<span class="string">"appid"</span>, WX_APPID);<span class="comment">//公众号id</span></span><br><span class="line">map.put(<span class="string">"nonce_str"</span>, nonceStr);<span class="comment">//随机字符串</span></span><br><span class="line">map.put(<span class="string">"notify_url"</span>, WX_PAY_CALLBACK);<span class="comment">//异步回调api</span></span><br><span class="line">map.put(<span class="string">"spbill_create_ip"</span>, ip);<span class="comment">//支付ip</span></span><br><span class="line">map.put(<span class="string">"out_trade_no"</span>, orderSn);<span class="comment">//商品订单号</span></span><br><span class="line">map.put(<span class="string">"total_fee"</span>, relAmount);<span class="comment">//真实金额</span></span><br><span class="line">map.put(<span class="string">"trade_type"</span>, <span class="string">"JSAPI"</span>);<span class="comment">//JSAPI、h5调用</span></span><br><span class="line">map.put(<span class="string">"openid"</span>, openid);<span class="comment">//支付用户openid</span></span><br><span class="line"><span class="type">String</span> <span class="variable">paySign</span> <span class="operator">=</span> <span class="string">""</span>;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">paySign = WeixinUtil.getPayCustomSign(map,key);<span class="comment">//WeixinUtil类会在下面展示</span></span><br><span class="line"><span class="comment">//这一句是签名生成算法</span></span><br><span class="line">} <span class="keyword">catch</span> (Exception e) {</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">}</span><br><span class="line">map.put(<span class="string">"sign"</span>,paySign);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"sign  "</span> + paySign);</span><br><span class="line"><span class="type">String</span> <span class="variable">xml</span> <span class="operator">=</span> <span class="string">"&lt;xml&gt;"</span> +</span><br><span class="line">                <span class="string">"&lt;appid&gt;"</span>+ WX_APPID +<span class="string">"&lt;/appid&gt;"</span>+</span><br><span class="line">                <span class="string">"&lt;body&gt;"</span>+ body +<span class="string">"&lt;/body&gt;"</span>+</span><br><span class="line">                <span class="string">"&lt;mch_id&gt;"</span>+ MCHID +<span class="string">"&lt;/mch_id&gt;"</span>+</span><br><span class="line">                <span class="string">"&lt;nonce_str&gt;"</span>+ nonceStr +<span class="string">"&lt;/nonce_str&gt;"</span>+</span><br><span class="line">                <span class="string">"&lt;notify_url&gt;"</span>+ WX_PAY_CALLBACK +<span class="string">"&lt;/notify_url&gt;"</span>+</span><br><span class="line">                <span class="string">"&lt;openid&gt;"</span>+ openid +<span class="string">"&lt;/openid&gt;"</span>+</span><br><span class="line">                <span class="string">"&lt;out_trade_no&gt;"</span>+ orderSn +<span class="string">"&lt;/out_trade_no&gt;"</span>+</span><br><span class="line">                <span class="string">"&lt;spbill_create_ip&gt;"</span>+ ip +<span class="string">"&lt;/spbill_create_ip&gt;"</span>+</span><br><span class="line">                <span class="string">"&lt;total_fee&gt;"</span>+ relAmount + <span class="string">""</span> +<span class="string">"&lt;/total_fee&gt;"</span>+</span><br><span class="line">                <span class="string">"&lt;trade_type&gt;JSAPI&lt;/trade_type&gt;"</span>+</span><br><span class="line">                <span class="string">"&lt;sign&gt;"</span>+ paySign +<span class="string">"&lt;/sign&gt;"</span>+</span><br><span class="line">             <span class="string">"&lt;/xml&gt;"</span>;</span><br><span class="line">System.out.println(xml);</span><br><span class="line"><span class="comment">//将map转为XML格式</span></span><br><span class="line"><span class="comment">//统一下单，这里不用改 </span></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">"https://api.mch.weixin.qq.com/pay/unifiedorder"</span>; <span class="comment">//统一下单接口</span></span><br><span class="line"><span class="type">String</span> <span class="variable">xmlStr</span> <span class="operator">=</span> WeixinUtil.post(url, xml); <span class="comment">//post请求数据</span></span><br><span class="line">System.out.println(xmlStr);</span><br><span class="line"><span class="type">String</span> <span class="variable">prepayid</span> <span class="operator">=</span> <span class="string">""</span>; </span><br><span class="line"><span class="keyword">if</span> (xmlStr.indexOf(<span class="string">"SUCCESS"</span>) != -<span class="number">1</span>) {  </span><br><span class="line">Map&lt;String, String&gt; map2 = <span class="literal">null</span>;  </span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">map2 = WeixinUtil.xmlToMap(xmlStr);  </span><br><span class="line">} <span class="keyword">catch</span> (Exception e) {</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">}  </span><br><span class="line"></span><br><span class="line">prepayid = (String) map2.get(<span class="string">"prepay_id"</span>);  <span class="comment">//获取prepayid</span></span><br><span class="line">System.out.println(<span class="string">"prepay_id  "</span> + prepayid);</span><br></pre></td></tr></tbody></table></figure><p>现在如果返回了prepay id，那么这一步就算完成，如果出现错误，一般都是签名出错，这时候就要好好看看有没有语法错误，或者签名算法有误。</p><p>3.第二次签名，然后传值到前端</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> System.currentTimeMillis() / <span class="number">1000</span>; <span class="comment">//时间戳</span></span><br><span class="line">Map&lt;String, String&gt; signMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">signMap.put(<span class="string">"appId"</span>, WX_APPID);<span class="comment">//appid</span></span><br><span class="line">signMap.put(<span class="string">"timeStamp"</span>, String.valueOf(timestamp));</span><br><span class="line">signMap.put(<span class="string">"nonceStr"</span>, nonceStr);</span><br><span class="line">signMap.put(<span class="string">"package"</span>, <span class="string">"prepay_id="</span>+prepayid);</span><br><span class="line">signMap.put(<span class="string">"signType"</span>, <span class="string">"MD5"</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">paySign2</span> <span class="operator">=</span> <span class="string">""</span>;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">paySign2 = WeixinUtil.getPayCustomSign(signMap,key);</span><br><span class="line">System.out.println(paySign2);</span><br><span class="line">} <span class="keyword">catch</span> (Exception e) {</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">}</span><br><span class="line">System.out.println(<span class="string">"timestamp"</span> + timestamp);</span><br><span class="line"><span class="comment">//以下的数据需要传到前端，可以用自己的方法传值</span></span><br><span class="line">request.setAttribute(<span class="string">"appId"</span>, WX_APPID); </span><br><span class="line">request.setAttribute(<span class="string">"paytimestamp"</span>, String.valueOf(timestamp));</span><br><span class="line">request.setAttribute(<span class="string">"paynonceStr"</span>, nonceStr);</span><br><span class="line">request.setAttribute(<span class="string">"paypackage"</span>, <span class="string">"prepay_id="</span>+prepayid);</span><br><span class="line">request.setAttribute(<span class="string">"paysignType"</span>,<span class="string">"MD5"</span>);</span><br><span class="line">request.setAttribute(<span class="string">"paySign"</span>, paySign2);</span><br><span class="line"><span class="comment">//去到确认支付页面,返回页面方式不同,(例：pay.html页面)</span></span><br></pre></td></tr></tbody></table></figure><p>4.H5调用微信支付接口  <a href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=7_7&amp;index=6">官方文档</a>内含代码<br>只需把参数改为自己的，调用接口就可以完成支付</p><p>5.我用到的WeixinUtil类，只是写了用到的一部分，导入的包可能很多没用。。    </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">import</span> java.sql.Timestamp;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.DocumentBuilder;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.DocumentBuilderFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpEntity;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpResponse;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.ClientProtocolException;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods.HttpGet;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods.HttpPost;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.entity.StringEntity;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.DefaultHttpClient;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.util.EntityUtils;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.Node;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.NodeList;</span><br><span class="line"><span class="keyword">import</span> org.xmlpull.v1.XmlPullParser;</span><br><span class="line"><span class="keyword">import</span> org.xmlpull.v1.XmlPullParserException;</span><br><span class="line"><span class="keyword">import</span> org.xmlpull.v1.XmlPullParserFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.json.JSONObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeixinUtil</span> {</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String hexDigits[] = { <span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>,  </span><br><span class="line">        <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span> };  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">post</span><span class="params">(String url,String outStr)</span>{</span><br><span class="line"><span class="type">DefaultHttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultHttpClient</span>();</span><br><span class="line"><span class="type">HttpPost</span> <span class="variable">httpPost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(url);</span><br><span class="line"><span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span><span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">httpPost.setEntity(<span class="keyword">new</span> <span class="title class_">StringEntity</span>(outStr, <span class="string">"utf-8"</span>));</span><br><span class="line"><span class="type">HttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> httpClient.execute(httpPost);</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> EntityUtils.toString(response.getEntity(),<span class="string">"utf-8"</span>);</span><br><span class="line">res = result;</span><br><span class="line">} <span class="keyword">catch</span> (UnsupportedEncodingException e) {</span><br><span class="line">e.printStackTrace();</span><br><span class="line">} <span class="keyword">catch</span> (ClientProtocolException e) {</span><br><span class="line">e.printStackTrace();</span><br><span class="line">} <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">e.printStackTrace();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取支付所需签名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getPayCustomSign</span><span class="params">(Map&lt;String, String&gt; bizObj,String key)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">String</span> <span class="variable">bizString</span> <span class="operator">=</span> FormatBizQueryParaMap(bizObj, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> sign(bizString, key);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//支付所需签名处调用此方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">sign</span><span class="params">(String content, String key)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception{</span><br><span class="line">        <span class="type">String</span> <span class="variable">signStr</span> <span class="operator">=</span> <span class="string">""</span>;</span><br><span class="line">        signStr = content + <span class="string">"&amp;key="</span> + key;</span><br><span class="line">        <span class="keyword">return</span> MD5(signStr).toUpperCase();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//上一方法，MD5加密处理</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String <span class="title function_">MD5</span><span class="params">(String s)</span> {</span><br><span class="line">        <span class="type">char</span> hexDigits[]={<span class="string">'0'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'F'</span>};       </span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">byte</span>[] btInput = s.getBytes();</span><br><span class="line">            <span class="type">MessageDigest</span> <span class="variable">mdInst</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line">            mdInst.update(btInput);</span><br><span class="line">            <span class="type">byte</span>[] md = mdInst.digest();</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> md.length;</span><br><span class="line">            <span class="type">char</span> str[] = <span class="keyword">new</span> <span class="title class_">char</span>[j * <span class="number">2</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; j; i++) {</span><br><span class="line">                <span class="type">byte</span> <span class="variable">byte0</span> <span class="operator">=</span> md[i];</span><br><span class="line">                str[k++] = hexDigits[byte0 &gt;&gt;&gt; <span class="number">4</span> &amp; <span class="number">0xf</span>];</span><br><span class="line">                str[k++] = hexDigits[byte0 &amp; <span class="number">0xf</span>];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(str);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字典排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">FormatBizQueryParaMap</span><span class="params">(Map&lt;String, String&gt; paraMap,</span></span><br><span class="line"><span class="params">            <span class="type">boolean</span> urlencode)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">String</span> <span class="variable">buff</span> <span class="operator">=</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            List&lt;Map.Entry&lt;String, String&gt;&gt; infoIds = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Map.Entry&lt;String, String&gt;&gt;(paraMap.entrySet());</span><br><span class="line">            Collections.sort(infoIds,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Map.Entry&lt;String, String&gt;&gt;() {</span><br><span class="line">           <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Map.Entry&lt;String, String&gt; o1,</span></span><br><span class="line"><span class="params">                  Map.Entry&lt;String, String&gt; o2)</span> {</span><br><span class="line">                 <span class="keyword">return</span> (o1.getKey()).toString().compareTo(</span><br><span class="line">                                    o2.getKey());</span><br><span class="line">                        }</span><br><span class="line">                    });</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; infoIds.size(); i++) {</span><br><span class="line">                Map.Entry&lt;String, String&gt; item = infoIds.get(i);</span><br><span class="line">                <span class="comment">//System.out.println(item.getKey());</span></span><br><span class="line">                <span class="keyword">if</span> (item.getKey() != <span class="string">""</span>) {</span><br><span class="line">                    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> item.getKey();</span><br><span class="line">                    <span class="type">String</span> <span class="variable">val</span> <span class="operator">=</span> item.getValue();</span><br><span class="line">                    <span class="keyword">if</span> (urlencode) {</span><br><span class="line">                        val = URLEncoder.encode(val, <span class="string">"utf-8"</span>);</span><br><span class="line">                    }</span><br><span class="line">                    buff += key + <span class="string">"="</span> + val + <span class="string">"&amp;"</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (buff.isEmpty() == <span class="literal">false</span>) {</span><br><span class="line">                buff = buff.substring(<span class="number">0</span>, buff.length() - <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(e.getMessage());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> buff;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, String&gt; <span class="title function_">xmlToMap</span><span class="params">(String strXML)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Map&lt;String, String&gt; data = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">            <span class="type">DocumentBuilderFactory</span> <span class="variable">documentBuilderFactory</span> <span class="operator">=</span> DocumentBuilderFactory.newInstance();</span><br><span class="line">            <span class="type">DocumentBuilder</span> <span class="variable">documentBuilder</span> <span class="operator">=</span> documentBuilderFactory.newDocumentBuilder();</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">stream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(strXML.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">            org.w3c.dom.<span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> documentBuilder.parse(stream);</span><br><span class="line">            doc.getDocumentElement().normalize();</span><br><span class="line">            <span class="type">NodeList</span> <span class="variable">nodeList</span> <span class="operator">=</span> doc.getDocumentElement().getChildNodes();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>; idx &lt; nodeList.getLength(); ++idx) {</span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nodeList.item(idx);</span><br><span class="line">                <span class="keyword">if</span> (node.getNodeType() == Node.ELEMENT_NODE) {</span><br><span class="line">                    org.w3c.dom.<span class="type">Element</span> <span class="variable">element</span> <span class="operator">=</span> (org.w3c.dom.Element) node;</span><br><span class="line">                    data.put(element.getNodeName(), element.getTextContent());</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                stream.close();</span><br><span class="line">            } <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">                <span class="comment">// do nothing</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        } <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">            <span class="comment">//WXPayUtil.getLogger().warn("Invalid XML, can not convert to map. Error message: {}. XML content: {}", ex.getMessage(), strXML);</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>官方文档写的比较难懂，其他的又比较杂，有的不能用，当然也可以github找demo，这也是我第一次做这些，写的很难看不要在意，如果有错的地方希望提出来，欢迎指导交流。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信公众号带参二维码的生成与解析（java)</title>
      <link href="/2017/10/02/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%B8%A6%E5%8F%82%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E8%A7%A3%E6%9E%90/"/>
      <url>/2017/10/02/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%B8%A6%E5%8F%82%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>这些日子一直在做微信公众号的开发，从头开始学，觉得特别复杂，接口一堆，开发文档看不懂，各种bug，由于现在二维码的广泛流传，接触了带参二维码，写一下生成与解析</p><h2 id="带参二维码介绍"><a href="#带参二维码介绍" class="headerlink" title="带参二维码介绍"></a>带参二维码介绍</h2><p>为了满足我们这些用户的需要，公众平台提供了生成带参数二维码的接口。使用该接口可以获得多个带不同场景值的二维码，用户扫描后，公众号可以接收到事件推送。说白了就是可以生成带参数的二维码，后台可以根据参数做出不同的反应，然后推送信息给用户，使一些操作简单化。</p><p>目前有2种类型的二维码，分别是临时二维码和永久二维码，前者有过期时间，但能够生成较多数量，后者无过期时间，数量较少（目前参数只支持1–100000），而且参数只能是整数。</p><p>用户扫描带场景值二维码时，可能推送以下两种事件：<br>如果用户还未关注公众号，则用户可以关注公众号，关注后微信会将带场景值关注事件推送给开发者。<br>如果用户已经关注公众号，在用户扫描后会自动进入会话，微信也会将带场景值扫描事件推送给开发者。</p><h2 id="带参二维码的生成"><a href="#带参二维码的生成" class="headerlink" title="带参二维码的生成"></a>带参二维码的生成</h2><p>1.首先创建二维码ticket，然后凭借ticket到指定URL换取二维码<br>2.然后会返回一个链接，打开就是一个二维码</p><p>当然这些前提就是有公众号并且前期的开发配置已完成，服务器域名什么的都配好了，也认证了，或者用的测试号都可以</p><p>创建二维码ticket需要提供一个开发者自行设定的参数（scene_id），这个就是所谓的参数（整数）</p><blockquote><p>http请求URL<br><a href="https://api.weixin.qq.com/cgi-bin/qrcode/create?access_token=TOKEN">https://api.weixin.qq.com/cgi-bin/qrcode/create?access_token=TOKEN</a></p></blockquote><p>POST数据格式(临时二维码)</p><blockquote><p>{ “expire_seconds”: 1800,”action_name”: “QR_SCENE”,”action_info”: {“scene”: {“scene_id”: 100000}}}</p></blockquote><p>其中expire_seconds就是存在的时间，action_name确定二维码是永久的还是临时的，详细参数的可以看微信开发文档。</p><p>返回格式：（临时二维码)        </p><blockquote><p>{“ticket”:”gQFK8DoAAAAAAAAAASxodHRwOi8vd2VpeGluLnFxLmNvbS9xL3kweXE0T3JscWY3UTltc3ZPMklvAAIEG9jUUgMECAcAAA==”,”expire_seconds”: 1800}</p></blockquote><p>代码:     </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JSONObject</span> <span class="variable">tjsonObj</span> <span class="operator">=</span> getTicketJsonObj(<span class="number">6</span>,<span class="number">604800</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">ticketString</span> <span class="operator">=</span> tjsonObj.getString(<span class="string">"ticket"</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">expire_seconds</span> <span class="operator">=</span> tjsonObj.getInt(<span class="string">"expire_seconds"</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> tjsonObj.getString(<span class="string">"url"</span>);</span><br><span class="line">System.out.println(<span class="string">"ticketString:"</span>+ticketString);</span><br><span class="line">System.out.println(<span class="string">"expire_seconds:"</span>+expire_seconds);</span><br><span class="line">System.out.println(<span class="string">"url:"</span>+url);</span><br><span class="line"><span class="type">String</span> <span class="variable">qrcodeUrl</span> <span class="operator">=</span> getQrcodeUrl(tjsonObj);</span><br><span class="line">System.out.println(<span class="string">"qrcodeUrl:"</span>+qrcodeUrl);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> JSONObject <span class="title function_">getTicketJsonObj</span><span class="params">(<span class="type">int</span> scene_id,<span class="type">int</span> expire_seconds)</span>{</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">ticket.append(<span class="string">"{\"expire_seconds\":"</span>);</span><br><span class="line">ticket.append(Integer.toString(expire_seconds));</span><br><span class="line">ticket.append(<span class="string">",\"action_name\":\"QR_SCENE\","</span>);</span><br><span class="line">ticket.append(<span class="string">"\"action_info\":{\"scene\":{\"scene_id\":"</span>);</span><br><span class="line">ticket.append(Integer.toString(scene_id));</span><br><span class="line">ticket.append(<span class="string">"}}}"</span>);</span><br><span class="line"><span class="type">AccessTokenDao</span> <span class="variable">atDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AccessTokenDao</span>();</span><br><span class="line">atDao.checkToken();</span><br><span class="line"><span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> atDao.getAccessTokenBySQL().getToken();</span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> TICKET_URL.replace(<span class="string">"TOKEN"</span>, token);</span><br><span class="line"><span class="type">String</span> <span class="variable">ticket1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(ticket); </span><br><span class="line"><span class="keyword">return</span> doPostStr(url, ticket1);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> JSONObject <span class="title function_">doPostStr</span><span class="params">(String url,String outStr)</span>{</span><br><span class="line"><span class="type">DefaultHttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultHttpClient</span>();</span><br><span class="line"><span class="type">HttpPost</span> <span class="variable">httpPost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(url);</span><br><span class="line"><span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span><span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">httpPost.setEntity(<span class="keyword">new</span> <span class="title class_">StringEntity</span>(outStr, <span class="string">"utf-8"</span>));</span><br><span class="line"><span class="type">HttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> httpClient.execute(httpPost);</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> EntityUtils.toString(response.getEntity(),<span class="string">"utf-8"</span>);</span><br><span class="line">jsonObject = JSONObject.fromObject(result);</span><br><span class="line">} <span class="keyword">catch</span> (UnsupportedEncodingException e) {</span><br><span class="line">e.printStackTrace();</span><br><span class="line">} <span class="keyword">catch</span> (ClientProtocolException e) {</span><br><span class="line">e.printStackTrace();</span><br><span class="line">} <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">e.printStackTrace();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> jsonObject;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getQrcodeUrl</span><span class="params">(JSONObject ticketObj)</span>{</span><br><span class="line"><span class="type">String</span> <span class="variable">ticketString</span> <span class="operator">=</span> ticketObj.getString(<span class="string">"ticket"</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span><span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">url = QRCODE_URL.replace(<span class="string">"TICKET"</span>, URLEncoder.encode(ticketString,<span class="string">"utf-8"</span>));</span><br><span class="line">} <span class="keyword">catch</span> (UnsupportedEncodingException e) {</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> url;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>现在就得到了url，打开就是二维码的图片</p><h2 id="带参二维码的解析"><a href="#带参二维码的解析" class="headerlink" title="带参二维码的解析"></a>带参二维码的解析</h2><p>微信公众平台推送的消息一般是xml来做的。<br>用户扫描带场景值二维码时，可能推送以下两种事件：<br>如果用户还未关注公众号，则用户可以关注公众号，关注后微信会将带场景值关注事件推送给开发者。<br>如果用户已经关注公众号，则微信会将带场景值扫描事件推送给开发者。     </p><ol><li>用户未关注时，进行关注后的事件推送<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ToUserName</span>&gt;</span>&lt;![CDATA[gh_45072270791c]]&gt;<span class="tag">&lt;/<span class="name">ToUserName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">FromUserName</span>&gt;</span>&lt;![CDATA[o7Lp5t6n59DeX3U0C7Kric9qEx-Q]]&gt;<span class="tag">&lt;/<span class="name">FromUserName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">CreateTime</span>&gt;</span>1389684286<span class="tag">&lt;/<span class="name">CreateTime</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MsgType</span>&gt;</span>&lt;![CDATA[event]]&gt;<span class="tag">&lt;/<span class="name">MsgType</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Event</span>&gt;</span>&lt;![CDATA[subscribe]]&gt;<span class="tag">&lt;/<span class="name">Event</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">EventKey</span>&gt;</span>&lt;![CDATA[qrscene_1000]]&gt;<span class="tag">&lt;/<span class="name">EventKey</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Ticket</span>&gt;</span>&lt;![CDATA[gQHi8DoAAAAAAAAAASxodHRwOi8vd2VpeGluLnFxLmNvbS9xL0UweTNxNi1sdlA3RklyRnNKbUFvAAIELdnUUgMEAAAAAA==]]&gt;<span class="tag">&lt;/<span class="name">Ticket</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>其中EventKey包括参数。     </li><li>用户已关注时的事件推送<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ToUserName</span>&gt;</span>&lt;![CDATA[gh_45072270791c]]&gt;<span class="tag">&lt;/<span class="name">ToUserName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">FromUserName</span>&gt;</span>&lt;![CDATA[o7Lp5t6n59DeX3U0C7Kric9qEx-Q]]&gt;<span class="tag">&lt;/<span class="name">FromUserName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">CreateTime</span>&gt;</span>1389684184<span class="tag">&lt;/<span class="name">CreateTime</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MsgType</span>&gt;</span>&lt;![CDATA[event]]&gt;<span class="tag">&lt;/<span class="name">MsgType</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Event</span>&gt;</span>&lt;![CDATA[SCAN]]&gt;<span class="tag">&lt;/<span class="name">Event</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">EventKey</span>&gt;</span>&lt;![CDATA[1000]]&gt;<span class="tag">&lt;/<span class="name">EventKey</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Ticket</span>&gt;</span>&lt;![CDATA[gQHi8DoAAAAAAAAAASxodHRwOi8vd2VpeGluLnFxLmNvbS9xL0UweTNxNi1sdlA3RklyRnNKbUFvAAIELdnUUgMEAAAAAA==]]&gt;<span class="tag">&lt;/<span class="name">Ticket</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>然后就可以解析这些事件，来做出响应。<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line"><span class="keyword">throws</span> ServletException, IOException {</span><br><span class="line"></span><br><span class="line">request.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">response.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">Map&lt;String, String&gt; map = MessageUtil.xmlToMap(request);</span><br><span class="line"><span class="type">String</span> <span class="variable">toUserName</span> <span class="operator">=</span> map.get(<span class="string">"ToUserName"</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">fromUserName</span> <span class="operator">=</span> map.get(<span class="string">"FromUserName"</span>);<span class="comment">// openid</span></span><br><span class="line"><span class="type">String</span> <span class="variable">msgType</span> <span class="operator">=</span> map.get(<span class="string">"MsgType"</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> map.get(<span class="string">"Content"</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (MessageUtil.MESSAGE_TEXT.equals(msgType)) {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (MessageUtil.MESSAGE_EVENT.equals(msgType)) {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">} <span class="keyword">catch</span> (DocumentException e) {</span><br><span class="line">e.printStackTrace();</span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">out.close();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>自己可以做一些相关的功能实现或者返回消息给用户</li></ol><p>代码部分是网上的，部分是自己的，写的不好，只是一个大概的方法步骤。<br>如有错误，希望指出</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐几个有趣的网址</title>
      <link href="/2017/09/12/%E6%8E%A8%E8%8D%90%E5%87%A0%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84%E7%BD%91%E5%9D%80/"/>
      <url>/2017/09/12/%E6%8E%A8%E8%8D%90%E5%87%A0%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84%E7%BD%91%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<p>这是在网上发现的一些有趣的网址</p><p>1 <a href="http://virtocean.com/">http://virtocean.com/</a><br>可以在线倾听海洋里的各种声音,配着3D的海洋效果<br><img src="https://i.loli.net/2017/09/12/59b783d12db92.png" alt="3"></p><p>2 <a href="http://upuptoyou.com/">http://upuptoyou.com/</a><br>这个可以输入一些字符（汉字），生成一张小人举牌的图片<br><img src="https://i.loli.net/2017/09/12/59b78502e4898.png" alt="举牌小人1"></p><p>3 <a href="http://lights.helloenjoy.com/">http://lights.helloenjoy.com/</a><br>一个特别绚丽的网页，如同一个mv</p><p>4 <a href="https://cn.codecombat.com/play">https://cn.codecombat.com/play</a><br>一个游戏网站，但不同的是可以学习编程，在打游戏的过程顺便学学python<br><img src="https://i.loli.net/2017/09/12/59b78691732aa.png" alt="编程游戏2"></p><p>5 <a href="https://www.jiumodiary.com/">https://www.jiumodiary.com/</a><br>一个搜索电子书的网站，提供很多格式，作为小说爱好者不妨看看</p><p>6 <a href="http://glench.com/hash/#CLICK">http://glench.com/hash/#CLICK</a><br>一个很魔性的网站，点开看看地址栏你会明白的，重点是地址栏<br></p><p>7 <a href="http://makeagif.com/">http://makeagif.com/</a><br>这个该收藏的，可以在线将视频转换为gif,youtube视频转换GIF最为方便,直接将链接复制就行<br><img src="https://i.loli.net/2017/09/12/59b78b33bbc92.png" alt="gif4"></p><p>8 <a href="http://produckhunt.co/">http://produckhunt.co/</a><br>打鸭子游戏，不过这个是手机电脑同步，拿手机当做枪<br><img src="https://i.loli.net/2017/09/12/59b78b4e0ac22.png" alt="打鸭子5"></p><p>9 <a href="https://cn.office-converter.com/">https://cn.office-converter.com/</a><br>在线文件格式转换，支持很多文档格式互换</p><p>10 <a href="http://race.assassinscreedpirates.com/">http://race.assassinscreedpirates.com/</a><br>网页版的刺客信条<br><img src="https://i.loli.net/2017/09/12/59b79118567ce.png" alt="刺客信条6"></p>]]></content>
      
      
      <categories>
          
          <category> 网址 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网址 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo+github搭建自己博客（绑定域名）</title>
      <link href="/2017/09/09/hexo+github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
      <url>/2017/09/09/hexo+github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>一直有些荒废，以前就想做个博客，但服务器贵不说，现在备案贼麻烦，后来知道GitHub上面可以做，用hexo或者Jekyll，我就用hexo+github 做了个博客，当然是用的别人摸板。。</p><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><p>先要安装git，<a href="https://git-scm.com/downloads">下载地址</a><br><br>然后安装，基本上是一直默认next，其中在这选第二个</p><p><img src="https://ooo.0o0.ooo/2017/09/11/59b687efbde51.jpg" alt="git安装">  </p><p>一路默认安装完成</p><h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><p>hexo是一款基于Node.js的静态博客框架，需要配置node.js的环境<br><br><a href="//nodejs.org/en/download/">下载地址</a><br>安装时一路默认就可以</p><h2 id="申请github账号-配置git个人信息"><a href="#申请github账号-配置git个人信息" class="headerlink" title="申请github账号,配置git个人信息"></a>申请github账号,配置git个人信息</h2><p>已有账号的的而且SSH keys配置的可以跳过<br><br>当然也可以自己百度/谷歌，可能更详细<br><br>1.设置Git的user name和email</p><blockquote><p>git config –global user.name “” (引号里面填)<br>git config –global user.email “”   </p></blockquote><p>2.生成密钥 SSH keys</p><blockquote><p>ssh-keygen -t rsa -C “邮箱”</p></blockquote><p>按3个回车，密码为空，最后得到了两个文件：id_rsa和id_rsa.pub，存放路径一般：c:/Users/xxxx_000/.ssh/</p><p>3.注册github账号，这个自己可以吧</p><p>4.登录github，点头像-&gt;Settings-&gt;SSH kyes-&gt;Add SSH key。<br>打开id_rsa.pub文件，全选复制公钥内容,将公钥粘贴到GitHub中Add an SSH key的key输入框，最后“Add Key”。</p><p>5.测试ssh keys是否设置成功。</p><blockquote><p>ssh -T <a href="mailto:git@github.com">git@github.com</a></p></blockquote><p>输入yes, 如果出现Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access. 说明设置成功。</p><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>1.创建文件夹，在哪都行，名字最好blog或者hexo什么的<br>2.在文件下，右键运行Git Bash<br>安装hexo</p><blockquote><p>sudo npm install -g hexo</p></blockquote><p>初始化hexo</p><blockquote><p>hexo init</p></blockquote><p>现在已经安装完成，这个文件就是博客根目录，所有操作都在这里面</p><h2 id="找一些主题，也可以克隆"><a href="#找一些主题，也可以克隆" class="headerlink" title="找一些主题，也可以克隆"></a>找一些主题，也可以克隆</h2><p>找到喜欢的主题后放到themes文件下<br>生成静态页面</p><blockquote><p>hexo generate（hexo g也可以）</p></blockquote><p>本地启动<br>启动本地服务，进行文章预览调试，命令：</p><blockquote><p>hexo server (hexo s)</p></blockquote><p>浏览器输入<a href="http://localhost:4000就可以本地查看博客">http://localhost:4000就可以本地查看博客</a></p><h2 id="配置到github上"><a href="#配置到github上" class="headerlink" title="配置到github上"></a>配置到github上</h2><p>github上面新建一个仓库new repository，仓库名必须为【your_user_name.github.io】，<br>例如 Hiccup1.github.io<br><img src="https://ooo.0o0.ooo/2017/09/11/59b68942d770e.png" alt="仓库名"></p><p>现在打开config.yml文件（自己建的文件夹下），来建立关联<br>翻到下面改成这个样子<br><img src="https://ooo.0o0.ooo/2017/09/11/59b687efa62c1.png" alt="config.yml"><br>注意冒号前面有空格<br>然后执行命令：</p><blockquote><p>npm install hexo-deployer-git –save</p></blockquote><p>接下来就可以发布到github上面</p><blockquote><p>hexo deploy(hexo d)</p></blockquote><p>一般指令就是</p><blockquote><p>hexo clean<br>hexo g  (生成静态文件)<br>hexo s  (启动本地服务,可以<a href="http://localhost:4000本地查看">http://localhost:4000本地查看</a>)<br>hexo d  (发布到github上)</p></blockquote><p>这时候就可以访问自己博客<a href="http://hiccup1.github.io/">http://Hiccup1.github.io</a> (改成你自己的)</p><p>如果自己有域名，可以绑定为自己域名<br>要将域名解析到github的地址（就是Hiccup1.github.io地址，你也可以ping自己的xx.github.io）</p><p>点击settings<br><img src="https://ooo.0o0.ooo/2017/09/11/59b687efb5264.png" alt="aa"></p><p>翻到下面,填上去，保存</p><p><img src="https://ooo.0o0.ooo/2017/09/11/59b687efb434b.png" alt="aaa"></p><p>也可以在根目录/source 目录下创建一个新文件CNAME(不带任何后缀)，直接在CNAME文件中写上自己的域名</p><blockquote><p>hexo g<br>hexo d </p></blockquote><p>就可以了</p><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p>写博客可以用Markdown </p><p>主题可以去网上找一下<br><a href="https://hexo.io/themes/">https://hexo.io/themes/</a><br><a href="http://www.jianshu.com/p/bcdbe7347c8d">http://www.jianshu.com/p/bcdbe7347c8d</a></p><p>对于博客需要图片什么的不推荐直接上传，可以在七牛云里面申请空间，七牛云存储也提供了免费CDN配额：存储空间 10GB，每月下载流量 10GB，每月 PUT/DELETE 10万次请求，每月 GET 100万次请求。月流量在10GB以下的博客基本上可以一直免费使用七牛云存储CDN服务了</p>]]></content>
      
      
      <categories>
          
          <category> hexo+github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tomcat 打开 startup.bat闪退</title>
      <link href="/2017/07/25/tomcat-%E6%89%93%E5%BC%80-startup-bat%E9%97%AA%E9%80%80/"/>
      <url>/2017/07/25/tomcat-%E6%89%93%E5%BC%80-startup-bat%E9%97%AA%E9%80%80/</url>
      
        <content type="html"><![CDATA[<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>tomcat安装好之后再bin目录下有startup.bat,双击之后闪退，这一般是由于环境变量设置问题</p><p>可以在cmd里查看相关信息，win+r 输入cmd，之后cd到tomcat安装目录的bin目录下，然后输入startup.bat如果提示缺少JAVA_HOME 或者缺少JRE_HOME，那么就是环境变量的问题，一般也就是这个错误</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>可以通过设置JAVA_HOME 和 JRE_HOME来解决，需要JDK，这个可以参考教程安装，安装好之后，计算机-&gt;属性-&gt;环境变量，win10是计算机-&gt;属性-&gt;高级系统设置-&gt;环境变量<br><img src="https://ooo.0o0.ooo/2017/09/11/59b6876b15998.png" alt="环境变量"><br>选择新建系统变量，变量名为JAVA_HOME，变量值为：JDK安装目录\jdk，然后新建JRE_HOME变量，变量值为jdk安装目录下jdk\jre<br><img src="https://ooo.0o0.ooo/2017/09/11/59b6876b17fdf.png" alt="JAVA"><br><img src="https://ooo.0o0.ooo/2017/09/11/59b6876b1927e.png" alt="jre"><br>之后将这两个变量放到path系统变量中，在path变量值的后面直接追加 ;%JAVA_HOME%;%JRE_HOME%<br>这个必须是这个格式，并且;不可少，如图<br><img src="https://ooo.0o0.ooo/2017/09/11/59b6876b1bd5d.png" alt="path"><br>保存之后就可以启动tomcat</p><blockquote><p>如有错误，欢迎指正</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> tomcat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tomcat </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
